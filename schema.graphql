# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
        "refresh the cache entry"
        refresh: Boolean! = false,
        "measured in seconds"
        ttl: Int! = 60
    ) on QUERY

interface IContactPoint {
    contact_type: String
    email: String
    iri: ID!
    telephone: String
}

interface IOrganization {
    account_manager: Person
    alt_label: String
    bzt: Boolean
    classification(label: String): Concept
    contact_point: [ContactPoint]
    description: String
    homepage: String
    id: String!
    iri: ID!
    label: String
    logo: Logo
    mam_label: String
    overlay: Boolean
    posts: [Post]
    primary_site: Site
    sites: [Site]
    units: [OrganizationalUnit]
}

type Concept {
    alt_label: String
    iri: ID!
    label: String
}

type ContactPoint implements IContactPoint {
    contact_type: String
    email: String
    iri: ID!
    telephone: String
}

type ContentPartner implements IOrganization {
    account_manager: Person
    alt_label: String
    bzt: Boolean
    classification(label: String): Concept
    contact_point: [ContactPoint]
    description: String
    homepage: String
    id: String!
    iri: ID!
    label: String
    logo: Logo
    mam_label: String
    overlay: Boolean
    posts: [Post]
    primary_site: Site
    sites: [Site]
    units: [OrganizationalUnit]
}

type Logo {
    iri: ID!
    type: Concept
}

type Organization implements IOrganization {
    account_manager: Person
    alt_label: String
    bzt: Boolean
    classification(label: String): Concept
    contact_point: [ContactPoint]
    description: String
    homepage: String
    id: String!
    iri: ID!
    label: String
    logo: Logo
    mam_label: String
    overlay: Boolean
    posts: [Post]
    primary_site: Site
    sites: [Site]
    units: [OrganizationalUnit]
}

type OrganizationalUnit implements IOrganization {
    account_manager: Person
    alt_label: String
    bzt: Boolean
    classification(label: String): Concept
    contact_point: [ContactPoint]
    description: String
    homepage: String
    id: String!
    iri: ID!
    label: String
    logo: Logo
    mam_label: String
    overlay: Boolean
    posts: [Post]
    primary_site: Site
    sites: [Site]
    unit_of: Organization!
    units: [OrganizationalUnit]
}

type Person {
    account_manager_of: [Organization]
    email: String
    family_name: String
    given_name: String
    holds: [Post]
    iri: ID!
    telephone: String
}

type Post {
    iri: ID!
    post_in: [Organization]!
    role: Concept
}

type PostalAddress implements IContactPoint {
    contact_type: String
    country: String
    email: String
    iri: ID!
    locality: String
    post_office_box_number: String
    postal_code: String
    region: String
    street: String
    telephone: String
}

type School implements IOrganization {
    account_manager: Person
    alt_label: String
    bzt: Boolean
    classification(label: String): Concept
    contact_point: [ContactPoint]
    description: String
    homepage: String
    id: String!
    iri: ID!
    label: String
    logo: Logo
    mam_label: String
    overlay: Boolean
    posts: [Post]
    primary_site: Site
    sites: [Site]
    units: [OrganizationalUnit]
}

type Site {
    address: PostalAddress
    iri: ID!
}

"""

Meldingen voor eindgebruikers over bepaalde activiteit


columns and relationships of "app.notification"
"""
type app_notification {
    created_at: timestamptz!
    description: String!
    id: uuid!
    "An object relationship"
    profile: users_profile!
    "Profile id van de bedoelde ontvanger"
    recipient: uuid!
    status: String!
    title: String!
    type: String!
    updated_at: timestamp!
    "An object relationship"
    visit: cp_visit
    "Indien de melding een bezoek(aanvraag) betreft"
    visit_id: uuid
}

"aggregated selection of \"app.notification\""
type app_notification_aggregate {
    aggregate: app_notification_aggregate_fields
    nodes: [app_notification!]!
}

"aggregate fields of \"app.notification\""
type app_notification_aggregate_fields {
    count(columns: [app_notification_select_column!], distinct: Boolean): Int!
    max: app_notification_max_fields
    min: app_notification_min_fields
}

"aggregate max on columns"
type app_notification_max_fields {
    created_at: timestamptz
    description: String
    id: uuid
    "Profile id van de bedoelde ontvanger"
    recipient: uuid
    status: String
    title: String
    type: String
    updated_at: timestamp
    "Indien de melding een bezoek(aanvraag) betreft"
    visit_id: uuid
}

"aggregate min on columns"
type app_notification_min_fields {
    created_at: timestamptz
    description: String
    id: uuid
    "Profile id van de bedoelde ontvanger"
    recipient: uuid
    status: String
    title: String
    type: String
    updated_at: timestamp
    "Indien de melding een bezoek(aanvraag) betreft"
    visit_id: uuid
}

"response of any mutation on the table \"app.notification\""
type app_notification_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [app_notification!]!
}

"columns and relationships of \"cms.content\""
type cms_content {
    "An array relationship"
    content_blocks(
        "distinct select on columns"
        distinct_on: [cms_content_blocks_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_blocks_order_by!],
        "filter the rows returned"
        where: cms_content_blocks_bool_exp
    ): [cms_content_blocks!]!
    "An aggregate relationship"
    content_blocks_aggregate(
        "distinct select on columns"
        distinct_on: [cms_content_blocks_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_blocks_order_by!],
        "filter the rows returned"
        where: cms_content_blocks_bool_exp
    ): cms_content_blocks_aggregate!
    "An array relationship"
    content_content_labels(
        "distinct select on columns"
        distinct_on: [cms_content_content_labels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_content_labels_order_by!],
        "filter the rows returned"
        where: cms_content_content_labels_bool_exp
    ): [cms_content_content_labels!]!
    "An aggregate relationship"
    content_content_labels_aggregate(
        "distinct select on columns"
        distinct_on: [cms_content_content_labels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_content_labels_order_by!],
        "filter the rows returned"
        where: cms_content_content_labels_bool_exp
    ): cms_content_content_labels_aggregate!
    content_type: String!
    content_width: String!
    created_at: timestamp!
    depublish_at: timestamp
    description: String
    header_path: String
    id: uuid!
    is_deleted: Boolean!
    is_protected: Boolean!
    is_public: Boolean
    meta_description: String
    "An object relationship"
    owner_profile: users_profile
    "slug van de pagina"
    path: String
    publish_at: timestamp
    published_at: timestamp
    seo_description: String
    seo_image_path: String
    seo_keywords: String
    seo_title: String
    thumbnail_path: String
    title: String!
    updated_at: timestamp
    updated_by_profile_id: uuid
    "An object relationship"
    updater_profile: users_profile
    user_group_ids(
        "JSON select path"
        path: String
    ): jsonb
    user_profile_id: uuid
}

"aggregated selection of \"cms.content\""
type cms_content_aggregate {
    aggregate: cms_content_aggregate_fields
    nodes: [cms_content!]!
}

"aggregate fields of \"cms.content\""
type cms_content_aggregate_fields {
    count(columns: [cms_content_select_column!], distinct: Boolean): Int!
    max: cms_content_max_fields
    min: cms_content_min_fields
}

"""

information for the blocks out of which the content pages are build


columns and relationships of "cms.content_blocks"
"""
type cms_content_blocks {
    "An object relationship"
    content: cms_content!
    content_block_type: String!
    content_id: uuid!
    created_at: timestamp!
    id: uuid!
    position: Int!
    updated_at: timestamp!
    variables(
        "JSON select path"
        path: String
    ): jsonb
}

"aggregated selection of \"cms.content_blocks\""
type cms_content_blocks_aggregate {
    aggregate: cms_content_blocks_aggregate_fields
    nodes: [cms_content_blocks!]!
}

"aggregate fields of \"cms.content_blocks\""
type cms_content_blocks_aggregate_fields {
    avg: cms_content_blocks_avg_fields
    count(columns: [cms_content_blocks_select_column!], distinct: Boolean): Int!
    max: cms_content_blocks_max_fields
    min: cms_content_blocks_min_fields
    stddev: cms_content_blocks_stddev_fields
    stddev_pop: cms_content_blocks_stddev_pop_fields
    stddev_samp: cms_content_blocks_stddev_samp_fields
    sum: cms_content_blocks_sum_fields
    var_pop: cms_content_blocks_var_pop_fields
    var_samp: cms_content_blocks_var_samp_fields
    variance: cms_content_blocks_variance_fields
}

"aggregate avg on columns"
type cms_content_blocks_avg_fields {
    position: Float
}

"aggregate max on columns"
type cms_content_blocks_max_fields {
    content_block_type: String
    content_id: uuid
    created_at: timestamp
    id: uuid
    position: Int
    updated_at: timestamp
}

"aggregate min on columns"
type cms_content_blocks_min_fields {
    content_block_type: String
    content_id: uuid
    created_at: timestamp
    id: uuid
    position: Int
    updated_at: timestamp
}

"response of any mutation on the table \"cms.content_blocks\""
type cms_content_blocks_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [cms_content_blocks!]!
}

"aggregate stddev on columns"
type cms_content_blocks_stddev_fields {
    position: Float
}

"aggregate stddev_pop on columns"
type cms_content_blocks_stddev_pop_fields {
    position: Float
}

"aggregate stddev_samp on columns"
type cms_content_blocks_stddev_samp_fields {
    position: Float
}

"aggregate sum on columns"
type cms_content_blocks_sum_fields {
    position: Int
}

"aggregate var_pop on columns"
type cms_content_blocks_var_pop_fields {
    position: Float
}

"aggregate var_samp on columns"
type cms_content_blocks_var_samp_fields {
    position: Float
}

"aggregate variance on columns"
type cms_content_blocks_variance_fields {
    position: Float
}

"""

linking table between content pages and the content_labels


columns and relationships of "cms.content_content_labels"
"""
type cms_content_content_labels {
    "An object relationship"
    content: cms_content!
    content_id: uuid!
    "An object relationship"
    content_label: cms_content_labels!
    created_at: timestamp!
    id: uuid!
    label_id: uuid!
    updated_at: timestamp!
}

"aggregated selection of \"cms.content_content_labels\""
type cms_content_content_labels_aggregate {
    aggregate: cms_content_content_labels_aggregate_fields
    nodes: [cms_content_content_labels!]!
}

"aggregate fields of \"cms.content_content_labels\""
type cms_content_content_labels_aggregate_fields {
    count(columns: [cms_content_content_labels_select_column!], distinct: Boolean): Int!
    max: cms_content_content_labels_max_fields
    min: cms_content_content_labels_min_fields
}

"aggregate max on columns"
type cms_content_content_labels_max_fields {
    content_id: uuid
    created_at: timestamp
    id: uuid
    label_id: uuid
    updated_at: timestamp
}

"aggregate min on columns"
type cms_content_content_labels_min_fields {
    content_id: uuid
    created_at: timestamp
    id: uuid
    label_id: uuid
    updated_at: timestamp
}

"response of any mutation on the table \"cms.content_content_labels\""
type cms_content_content_labels_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [cms_content_content_labels!]!
}

"""

labels to marks certain content pages and group them together


columns and relationships of "cms.content_labels"
"""
type cms_content_labels {
    "An array relationship"
    content_content_labels(
        "distinct select on columns"
        distinct_on: [cms_content_content_labels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_content_labels_order_by!],
        "filter the rows returned"
        where: cms_content_content_labels_bool_exp
    ): [cms_content_content_labels!]!
    "An aggregate relationship"
    content_content_labels_aggregate(
        "distinct select on columns"
        distinct_on: [cms_content_content_labels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_content_labels_order_by!],
        "filter the rows returned"
        where: cms_content_content_labels_bool_exp
    ): cms_content_content_labels_aggregate!
    content_type: String!
    created_at: timestamp!
    id: uuid!
    label: String!
    link_to(
        "JSON select path"
        path: String
    ): jsonb
    updated_at: timestamp!
}

"aggregated selection of \"cms.content_labels\""
type cms_content_labels_aggregate {
    aggregate: cms_content_labels_aggregate_fields
    nodes: [cms_content_labels!]!
}

"aggregate fields of \"cms.content_labels\""
type cms_content_labels_aggregate_fields {
    count(columns: [cms_content_labels_select_column!], distinct: Boolean): Int!
    max: cms_content_labels_max_fields
    min: cms_content_labels_min_fields
}

"aggregate max on columns"
type cms_content_labels_max_fields {
    content_type: String
    created_at: timestamp
    id: uuid
    label: String
    updated_at: timestamp
}

"aggregate min on columns"
type cms_content_labels_min_fields {
    content_type: String
    created_at: timestamp
    id: uuid
    label: String
    updated_at: timestamp
}

"response of any mutation on the table \"cms.content_labels\""
type cms_content_labels_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [cms_content_labels!]!
}

"aggregate max on columns"
type cms_content_max_fields {
    content_type: String
    content_width: String
    created_at: timestamp
    depublish_at: timestamp
    description: String
    header_path: String
    id: uuid
    meta_description: String
    "slug van de pagina"
    path: String
    publish_at: timestamp
    published_at: timestamp
    seo_description: String
    seo_image_path: String
    seo_keywords: String
    seo_title: String
    thumbnail_path: String
    title: String
    updated_at: timestamp
    updated_by_profile_id: uuid
    user_profile_id: uuid
}

"aggregate min on columns"
type cms_content_min_fields {
    content_type: String
    content_width: String
    created_at: timestamp
    depublish_at: timestamp
    description: String
    header_path: String
    id: uuid
    meta_description: String
    "slug van de pagina"
    path: String
    publish_at: timestamp
    published_at: timestamp
    seo_description: String
    seo_image_path: String
    seo_keywords: String
    seo_title: String
    thumbnail_path: String
    title: String
    updated_at: timestamp
    updated_by_profile_id: uuid
    user_profile_id: uuid
}

"response of any mutation on the table \"cms.content\""
type cms_content_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [cms_content!]!
}

"columns and relationships of \"cms.navigation_element\""
type cms_navigation_element {
    "id van de gelinkte content block pagina"
    content_id: uuid
    content_path: String!
    content_type: String!
    created_at: timestamptz!
    "beschrijving van het navigatie item. enkel zichtbaar voor beheerders"
    description: String
    icon_name: String!
    id: uuid!
    label: String!
    "open in new tab of in zelfde tab"
    link_target: String
    "In welk navigatiemenu verschijnt dit, vb. navigatiemenu linksboven, of footermenu."
    placement: String!
    "volgorde van de links in de navigatie balk 0, 1, 2, 3"
    position: Int!
    tooltip: String
    updated_at: timestamptz!
    user_group_ids(
        "JSON select path"
        path: String
    ): jsonb
}

"aggregated selection of \"cms.navigation_element\""
type cms_navigation_element_aggregate {
    aggregate: cms_navigation_element_aggregate_fields
    nodes: [cms_navigation_element!]!
}

"aggregate fields of \"cms.navigation_element\""
type cms_navigation_element_aggregate_fields {
    avg: cms_navigation_element_avg_fields
    count(columns: [cms_navigation_element_select_column!], distinct: Boolean): Int!
    max: cms_navigation_element_max_fields
    min: cms_navigation_element_min_fields
    stddev: cms_navigation_element_stddev_fields
    stddev_pop: cms_navigation_element_stddev_pop_fields
    stddev_samp: cms_navigation_element_stddev_samp_fields
    sum: cms_navigation_element_sum_fields
    var_pop: cms_navigation_element_var_pop_fields
    var_samp: cms_navigation_element_var_samp_fields
    variance: cms_navigation_element_variance_fields
}

"aggregate avg on columns"
type cms_navigation_element_avg_fields {
    "volgorde van de links in de navigatie balk 0, 1, 2, 3"
    position: Float
}

"aggregate max on columns"
type cms_navigation_element_max_fields {
    "id van de gelinkte content block pagina"
    content_id: uuid
    content_path: String
    content_type: String
    created_at: timestamptz
    "beschrijving van het navigatie item. enkel zichtbaar voor beheerders"
    description: String
    icon_name: String
    id: uuid
    label: String
    "open in new tab of in zelfde tab"
    link_target: String
    "In welk navigatiemenu verschijnt dit, vb. navigatiemenu linksboven, of footermenu."
    placement: String
    "volgorde van de links in de navigatie balk 0, 1, 2, 3"
    position: Int
    tooltip: String
    updated_at: timestamptz
}

"aggregate min on columns"
type cms_navigation_element_min_fields {
    "id van de gelinkte content block pagina"
    content_id: uuid
    content_path: String
    content_type: String
    created_at: timestamptz
    "beschrijving van het navigatie item. enkel zichtbaar voor beheerders"
    description: String
    icon_name: String
    id: uuid
    label: String
    "open in new tab of in zelfde tab"
    link_target: String
    "In welk navigatiemenu verschijnt dit, vb. navigatiemenu linksboven, of footermenu."
    placement: String
    "volgorde van de links in de navigatie balk 0, 1, 2, 3"
    position: Int
    tooltip: String
    updated_at: timestamptz
}

"response of any mutation on the table \"cms.navigation_element\""
type cms_navigation_element_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [cms_navigation_element!]!
}

"aggregate stddev on columns"
type cms_navigation_element_stddev_fields {
    "volgorde van de links in de navigatie balk 0, 1, 2, 3"
    position: Float
}

"aggregate stddev_pop on columns"
type cms_navigation_element_stddev_pop_fields {
    "volgorde van de links in de navigatie balk 0, 1, 2, 3"
    position: Float
}

"aggregate stddev_samp on columns"
type cms_navigation_element_stddev_samp_fields {
    "volgorde van de links in de navigatie balk 0, 1, 2, 3"
    position: Float
}

"aggregate sum on columns"
type cms_navigation_element_sum_fields {
    "volgorde van de links in de navigatie balk 0, 1, 2, 3"
    position: Int
}

"aggregate var_pop on columns"
type cms_navigation_element_var_pop_fields {
    "volgorde van de links in de navigatie balk 0, 1, 2, 3"
    position: Float
}

"aggregate var_samp on columns"
type cms_navigation_element_var_samp_fields {
    "volgorde van de links in de navigatie balk 0, 1, 2, 3"
    position: Float
}

"aggregate variance on columns"
type cms_navigation_element_variance_fields {
    "volgorde van de links in de navigatie balk 0, 1, 2, 3"
    position: Float
}

"""

Sitebrede variabelen zoals vertalingen


columns and relationships of "cms.site_variables"
"""
type cms_site_variables {
    created_at: timestamp!
    name: String!
    updated_at: timestamp!
    value(
        "JSON select path"
        path: String
    ): jsonb!
}

"aggregated selection of \"cms.site_variables\""
type cms_site_variables_aggregate {
    aggregate: cms_site_variables_aggregate_fields
    nodes: [cms_site_variables!]!
}

"aggregate fields of \"cms.site_variables\""
type cms_site_variables_aggregate_fields {
    count(columns: [cms_site_variables_select_column!], distinct: Boolean): Int!
    max: cms_site_variables_max_fields
    min: cms_site_variables_min_fields
}

"aggregate max on columns"
type cms_site_variables_max_fields {
    created_at: timestamp
    name: String
    updated_at: timestamp
}

"aggregate min on columns"
type cms_site_variables_min_fields {
    created_at: timestamp
    name: String
    updated_at: timestamp
}

"response of any mutation on the table \"cms.site_variables\""
type cms_site_variables_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [cms_site_variables!]!
}

"""

Informatie over de zoekindex per CP


columns and relationships of "cp.index"
"""
type cp_index {
    created_at: timestamp!
    "An object relationship"
    schema_maintainer: cp_maintainer!
    schema_maintainer_id: String!
    schema_name: String
    updated_at: timestamp!
}

"aggregated selection of \"cp.index\""
type cp_index_aggregate {
    aggregate: cp_index_aggregate_fields
    nodes: [cp_index!]!
}

"aggregate fields of \"cp.index\""
type cp_index_aggregate_fields {
    count(columns: [cp_index_select_column!], distinct: Boolean): Int!
    max: cp_index_max_fields
    min: cp_index_min_fields
}

"aggregate max on columns"
type cp_index_max_fields {
    created_at: timestamp
    schema_maintainer_id: String
    schema_name: String
    updated_at: timestamp
}

"aggregate min on columns"
type cp_index_min_fields {
    created_at: timestamp
    schema_maintainer_id: String
    schema_name: String
    updated_at: timestamp
}

"response of any mutation on the table \"cp.index\""
type cp_index_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [cp_index!]!
}

"""

Informatie over de organisatie die content beheert en aanbiedt, aka CP


columns and relationships of "cp.maintainer"
"""
type cp_maintainer {
    created_at: timestamp!
    has_index: Boolean!
    has_space: Boolean!
    "An array relationship"
    ies(
        "distinct select on columns"
        distinct_on: [object_ie_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_ie_order_by!],
        "filter the rows returned"
        where: object_ie_bool_exp
    ): [object_ie!]!
    "An aggregate relationship"
    ies_aggregate(
        "distinct select on columns"
        distinct_on: [object_ie_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_ie_order_by!],
        "filter the rows returned"
        where: object_ie_bool_exp
    ): object_ie_aggregate!
    "An object relationship"
    index: cp_index
    information(iri: String): [ContentPartner]
    "An array relationship"
    maintainer_users_profiles(
        "distinct select on columns"
        distinct_on: [cp_maintainer_users_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_maintainer_users_profile_order_by!],
        "filter the rows returned"
        where: cp_maintainer_users_profile_bool_exp
    ): [cp_maintainer_users_profile!]!
    "An aggregate relationship"
    maintainer_users_profiles_aggregate(
        "distinct select on columns"
        distinct_on: [cp_maintainer_users_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_maintainer_users_profile_order_by!],
        "filter the rows returned"
        where: cp_maintainer_users_profile_bool_exp
    ): cp_maintainer_users_profile_aggregate!
    schema_identifier: String!
    schema_name: String
    "An object relationship"
    space: cp_space
    updated_at: timestamp!
}

"aggregated selection of \"cp.maintainer\""
type cp_maintainer_aggregate {
    aggregate: cp_maintainer_aggregate_fields
    nodes: [cp_maintainer!]!
}

"aggregate fields of \"cp.maintainer\""
type cp_maintainer_aggregate_fields {
    count(columns: [cp_maintainer_select_column!], distinct: Boolean): Int!
    max: cp_maintainer_max_fields
    min: cp_maintainer_min_fields
}

"aggregate max on columns"
type cp_maintainer_max_fields {
    created_at: timestamp
    schema_identifier: String
    schema_name: String
    updated_at: timestamp
}

"aggregate min on columns"
type cp_maintainer_min_fields {
    created_at: timestamp
    schema_identifier: String
    schema_name: String
    updated_at: timestamp
}

"response of any mutation on the table \"cp.maintainer\""
type cp_maintainer_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [cp_maintainer!]!
}

"""

The user profiles that will manage this reading room


columns and relationships of "cp.maintainer_users_profile"
"""
type cp_maintainer_users_profile {
    id: uuid!
    "An object relationship"
    maintainer: cp_maintainer!
    maintainer_identifier: String!
    "An object relationship"
    profile: users_profile!
    users_profile_id: uuid!
}

"aggregated selection of \"cp.maintainer_users_profile\""
type cp_maintainer_users_profile_aggregate {
    aggregate: cp_maintainer_users_profile_aggregate_fields
    nodes: [cp_maintainer_users_profile!]!
}

"aggregate fields of \"cp.maintainer_users_profile\""
type cp_maintainer_users_profile_aggregate_fields {
    count(columns: [cp_maintainer_users_profile_select_column!], distinct: Boolean): Int!
    max: cp_maintainer_users_profile_max_fields
    min: cp_maintainer_users_profile_min_fields
}

"aggregate max on columns"
type cp_maintainer_users_profile_max_fields {
    id: uuid
    maintainer_identifier: String
    users_profile_id: uuid
}

"aggregate min on columns"
type cp_maintainer_users_profile_min_fields {
    id: uuid
    maintainer_identifier: String
    users_profile_id: uuid
}

"response of any mutation on the table \"cp.maintainer_users_profile\""
type cp_maintainer_users_profile_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [cp_maintainer_users_profile!]!
}

"""

Bezoekersruimte aka leeszaal van een CP


columns and relationships of "cp.space"
"""
type cp_space {
    created_at: timestamp
    id: uuid!
    is_published: Boolean
    published_at: timestamp
    "An object relationship"
    schemaAudienceTypeBySchemaAudienceType: lookup_schema_audience_type!
    schema_audience_type: lookup_schema_audience_type_enum!
    schema_color: String
    schema_description: String
    schema_image: String
    "An object relationship"
    schema_maintainer: cp_maintainer!
    schema_maintainer_id: String!
    schema_public_access: Boolean
    schema_service_description: String
    updated_at: timestamp
    "An array relationship"
    visits(
        "distinct select on columns"
        distinct_on: [cp_visit_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_order_by!],
        "filter the rows returned"
        where: cp_visit_bool_exp
    ): [cp_visit!]!
    "An aggregate relationship"
    visits_aggregate(
        "distinct select on columns"
        distinct_on: [cp_visit_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_order_by!],
        "filter the rows returned"
        where: cp_visit_bool_exp
    ): cp_visit_aggregate!
}

"aggregated selection of \"cp.space\""
type cp_space_aggregate {
    aggregate: cp_space_aggregate_fields
    nodes: [cp_space!]!
}

"aggregate fields of \"cp.space\""
type cp_space_aggregate_fields {
    count(columns: [cp_space_select_column!], distinct: Boolean): Int!
    max: cp_space_max_fields
    min: cp_space_min_fields
}

"aggregate max on columns"
type cp_space_max_fields {
    created_at: timestamp
    id: uuid
    published_at: timestamp
    schema_color: String
    schema_description: String
    schema_image: String
    schema_maintainer_id: String
    schema_service_description: String
    updated_at: timestamp
}

"aggregate min on columns"
type cp_space_min_fields {
    created_at: timestamp
    id: uuid
    published_at: timestamp
    schema_color: String
    schema_description: String
    schema_image: String
    schema_maintainer_id: String
    schema_service_description: String
    updated_at: timestamp
}

"response of any mutation on the table \"cp.space\""
type cp_space_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [cp_space!]!
}

"""

Bezoekaanvragen van gebruikers


columns and relationships of "cp.visit"
"""
type cp_visit {
    cp_space_id: uuid!
    created_at: timestamp!
    end_date: timestamp
    id: uuid!
    "An array relationship"
    notes(
        "distinct select on columns"
        distinct_on: [cp_visit_note_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_note_order_by!],
        "filter the rows returned"
        where: cp_visit_note_bool_exp
    ): [cp_visit_note!]!
    "An aggregate relationship"
    notes_aggregate(
        "distinct select on columns"
        distinct_on: [cp_visit_note_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_note_order_by!],
        "filter the rows returned"
        where: cp_visit_note_bool_exp
    ): cp_visit_note_aggregate!
    "An array relationship"
    notifications(
        "distinct select on columns"
        distinct_on: [app_notification_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [app_notification_order_by!],
        "filter the rows returned"
        where: app_notification_bool_exp
    ): [app_notification!]!
    "An aggregate relationship"
    notifications_aggregate(
        "distinct select on columns"
        distinct_on: [app_notification_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [app_notification_order_by!],
        "filter the rows returned"
        where: app_notification_bool_exp
    ): app_notification_aggregate!
    "An object relationship"
    space: cp_space!
    start_date: timestamp
    status: String!
    updated_at: timestamp!
    updated_by: uuid
    "An object relationship"
    updater: users_profile
    user_accepted_tos: Boolean
    "An object relationship"
    user_profile: users_profile!
    user_profile_id: uuid!
    user_reason: String
    user_timeframe: String
}

"aggregated selection of \"cp.visit\""
type cp_visit_aggregate {
    aggregate: cp_visit_aggregate_fields
    nodes: [cp_visit!]!
}

"aggregate fields of \"cp.visit\""
type cp_visit_aggregate_fields {
    count(columns: [cp_visit_select_column!], distinct: Boolean): Int!
    max: cp_visit_max_fields
    min: cp_visit_min_fields
}

"aggregate max on columns"
type cp_visit_max_fields {
    cp_space_id: uuid
    created_at: timestamp
    end_date: timestamp
    id: uuid
    start_date: timestamp
    status: String
    updated_at: timestamp
    updated_by: uuid
    user_profile_id: uuid
    user_reason: String
    user_timeframe: String
}

"aggregate min on columns"
type cp_visit_min_fields {
    cp_space_id: uuid
    created_at: timestamp
    end_date: timestamp
    id: uuid
    start_date: timestamp
    status: String
    updated_at: timestamp
    updated_by: uuid
    user_profile_id: uuid
    user_reason: String
    user_timeframe: String
}

"response of any mutation on the table \"cp.visit\""
type cp_visit_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [cp_visit!]!
}

"""

Notities en bemerkingen van een beheerder tijdens de levensduur van een bezoek, van aanvraag tot afronding


columns and relationships of "cp.visit_note"
"""
type cp_visit_note {
    created_at: timestamp!
    id: uuid!
    note: String!
    "An object relationship"
    profile: users_profile
    "Degene die de notitie heeft gemaakt"
    profile_id: uuid
    updated_at: timestamp!
    "An object relationship"
    visit: cp_visit!
    visit_id: uuid!
}

"aggregated selection of \"cp.visit_note\""
type cp_visit_note_aggregate {
    aggregate: cp_visit_note_aggregate_fields
    nodes: [cp_visit_note!]!
}

"aggregate fields of \"cp.visit_note\""
type cp_visit_note_aggregate_fields {
    count(columns: [cp_visit_note_select_column!], distinct: Boolean): Int!
    max: cp_visit_note_max_fields
    min: cp_visit_note_min_fields
}

"aggregate max on columns"
type cp_visit_note_max_fields {
    created_at: timestamp
    id: uuid
    note: String
    "Degene die de notitie heeft gemaakt"
    profile_id: uuid
    updated_at: timestamp
    visit_id: uuid
}

"aggregate min on columns"
type cp_visit_note_min_fields {
    created_at: timestamp
    id: uuid
    note: String
    "Degene die de notitie heeft gemaakt"
    profile_id: uuid
    updated_at: timestamp
    visit_id: uuid
}

"response of any mutation on the table \"cp.visit_note\""
type cp_visit_note_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [cp_visit_note!]!
}

"""

Types van notificaties aan eindgebruikers


columns and relationships of "lookup.app_notification_type"
"""
type lookup_app_notification_type {
    comment: String
    value: String!
}

"aggregated selection of \"lookup.app_notification_type\""
type lookup_app_notification_type_aggregate {
    aggregate: lookup_app_notification_type_aggregate_fields
    nodes: [lookup_app_notification_type!]!
}

"aggregate fields of \"lookup.app_notification_type\""
type lookup_app_notification_type_aggregate_fields {
    count(columns: [lookup_app_notification_type_select_column!], distinct: Boolean): Int!
    max: lookup_app_notification_type_max_fields
    min: lookup_app_notification_type_min_fields
}

"aggregate max on columns"
type lookup_app_notification_type_max_fields {
    comment: String
    value: String
}

"aggregate min on columns"
type lookup_app_notification_type_min_fields {
    comment: String
    value: String
}

"response of any mutation on the table \"lookup.app_notification_type\""
type lookup_app_notification_type_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [lookup_app_notification_type!]!
}

"""

Graphql enum types for content blocks


columns and relationships of "lookup.cms_content_block_type"
"""
type lookup_cms_content_block_type {
    description: String
    value: String!
}

"aggregated selection of \"lookup.cms_content_block_type\""
type lookup_cms_content_block_type_aggregate {
    aggregate: lookup_cms_content_block_type_aggregate_fields
    nodes: [lookup_cms_content_block_type!]!
}

"aggregate fields of \"lookup.cms_content_block_type\""
type lookup_cms_content_block_type_aggregate_fields {
    count(columns: [lookup_cms_content_block_type_select_column!], distinct: Boolean): Int!
    max: lookup_cms_content_block_type_max_fields
    min: lookup_cms_content_block_type_min_fields
}

"aggregate max on columns"
type lookup_cms_content_block_type_max_fields {
    description: String
    value: String
}

"aggregate min on columns"
type lookup_cms_content_block_type_min_fields {
    description: String
    value: String
}

"response of any mutation on the table \"lookup.cms_content_block_type\""
type lookup_cms_content_block_type_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [lookup_cms_content_block_type!]!
}

"""

GraphQL enum type for content types, e.g. pages, news, projects.


columns and relationships of "lookup.cms_content_type"
"""
type lookup_cms_content_type {
    description: String
    value: String!
}

"aggregated selection of \"lookup.cms_content_type\""
type lookup_cms_content_type_aggregate {
    aggregate: lookup_cms_content_type_aggregate_fields
    nodes: [lookup_cms_content_type!]!
}

"aggregate fields of \"lookup.cms_content_type\""
type lookup_cms_content_type_aggregate_fields {
    count(columns: [lookup_cms_content_type_select_column!], distinct: Boolean): Int!
    max: lookup_cms_content_type_max_fields
    min: lookup_cms_content_type_min_fields
}

"aggregate max on columns"
type lookup_cms_content_type_max_fields {
    description: String
    value: String
}

"aggregate min on columns"
type lookup_cms_content_type_min_fields {
    description: String
    value: String
}

"response of any mutation on the table \"lookup.cms_content_type\""
type lookup_cms_content_type_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [lookup_cms_content_type!]!
}

"""

de circle of life van een bezoek


columns and relationships of "lookup.cp_visit_status"
"""
type lookup_cp_visit_status {
    comment: String!
    value: String!
}

"aggregated selection of \"lookup.cp_visit_status\""
type lookup_cp_visit_status_aggregate {
    aggregate: lookup_cp_visit_status_aggregate_fields
    nodes: [lookup_cp_visit_status!]!
}

"aggregate fields of \"lookup.cp_visit_status\""
type lookup_cp_visit_status_aggregate_fields {
    count(columns: [lookup_cp_visit_status_select_column!], distinct: Boolean): Int!
    max: lookup_cp_visit_status_max_fields
    min: lookup_cp_visit_status_min_fields
}

"aggregate max on columns"
type lookup_cp_visit_status_max_fields {
    comment: String
    value: String
}

"aggregate min on columns"
type lookup_cp_visit_status_min_fields {
    comment: String
    value: String
}

"response of any mutation on the table \"lookup.cp_visit_status\""
type lookup_cp_visit_status_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [lookup_cp_visit_status!]!
}

"""

The target group associated with a given audience..


columns and relationships of "lookup.schema_audience_type"
"""
type lookup_schema_audience_type {
    comment: String
    value: String!
}

"aggregated selection of \"lookup.schema_audience_type\""
type lookup_schema_audience_type_aggregate {
    aggregate: lookup_schema_audience_type_aggregate_fields
    nodes: [lookup_schema_audience_type!]!
}

"aggregate fields of \"lookup.schema_audience_type\""
type lookup_schema_audience_type_aggregate_fields {
    count(columns: [lookup_schema_audience_type_select_column!], distinct: Boolean): Int!
    max: lookup_schema_audience_type_max_fields
    min: lookup_schema_audience_type_min_fields
}

"aggregate max on columns"
type lookup_schema_audience_type_max_fields {
    comment: String
    value: String
}

"aggregate min on columns"
type lookup_schema_audience_type_min_fields {
    comment: String
    value: String
}

"response of any mutation on the table \"lookup.schema_audience_type\""
type lookup_schema_audience_type_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [lookup_schema_audience_type!]!
}

"mutation root"
type mutation_root {
    "delete data from the table: \"app.notification\""
    delete_app_notification(
        "filter the rows which have to be deleted"
        where: app_notification_bool_exp!
    ): app_notification_mutation_response
    "delete single row from the table: \"app.notification\""
    delete_app_notification_by_pk(id: uuid!): app_notification
    "delete data from the table: \"cms.content\""
    delete_cms_content(
        "filter the rows which have to be deleted"
        where: cms_content_bool_exp!
    ): cms_content_mutation_response
    "delete data from the table: \"cms.content_blocks\""
    delete_cms_content_blocks(
        "filter the rows which have to be deleted"
        where: cms_content_blocks_bool_exp!
    ): cms_content_blocks_mutation_response
    "delete single row from the table: \"cms.content_blocks\""
    delete_cms_content_blocks_by_pk(id: uuid!): cms_content_blocks
    "delete single row from the table: \"cms.content\""
    delete_cms_content_by_pk(id: uuid!): cms_content
    "delete data from the table: \"cms.content_content_labels\""
    delete_cms_content_content_labels(
        "filter the rows which have to be deleted"
        where: cms_content_content_labels_bool_exp!
    ): cms_content_content_labels_mutation_response
    "delete single row from the table: \"cms.content_content_labels\""
    delete_cms_content_content_labels_by_pk(id: uuid!): cms_content_content_labels
    "delete data from the table: \"cms.content_labels\""
    delete_cms_content_labels(
        "filter the rows which have to be deleted"
        where: cms_content_labels_bool_exp!
    ): cms_content_labels_mutation_response
    "delete single row from the table: \"cms.content_labels\""
    delete_cms_content_labels_by_pk(id: uuid!): cms_content_labels
    "delete data from the table: \"cms.navigation_element\""
    delete_cms_navigation_element(
        "filter the rows which have to be deleted"
        where: cms_navigation_element_bool_exp!
    ): cms_navigation_element_mutation_response
    "delete single row from the table: \"cms.navigation_element\""
    delete_cms_navigation_element_by_pk(id: uuid!): cms_navigation_element
    "delete data from the table: \"cms.site_variables\""
    delete_cms_site_variables(
        "filter the rows which have to be deleted"
        where: cms_site_variables_bool_exp!
    ): cms_site_variables_mutation_response
    "delete single row from the table: \"cms.site_variables\""
    delete_cms_site_variables_by_pk(name: String!): cms_site_variables
    "delete data from the table: \"cp.index\""
    delete_cp_index(
        "filter the rows which have to be deleted"
        where: cp_index_bool_exp!
    ): cp_index_mutation_response
    "delete single row from the table: \"cp.index\""
    delete_cp_index_by_pk(schema_maintainer_id: String!): cp_index
    "delete data from the table: \"cp.maintainer\""
    delete_cp_maintainer(
        "filter the rows which have to be deleted"
        where: cp_maintainer_bool_exp!
    ): cp_maintainer_mutation_response
    "delete single row from the table: \"cp.maintainer\""
    delete_cp_maintainer_by_pk(schema_identifier: String!): cp_maintainer
    "delete data from the table: \"cp.maintainer_users_profile\""
    delete_cp_maintainer_users_profile(
        "filter the rows which have to be deleted"
        where: cp_maintainer_users_profile_bool_exp!
    ): cp_maintainer_users_profile_mutation_response
    "delete single row from the table: \"cp.maintainer_users_profile\""
    delete_cp_maintainer_users_profile_by_pk(id: uuid!): cp_maintainer_users_profile
    "delete data from the table: \"cp.space\""
    delete_cp_space(
        "filter the rows which have to be deleted"
        where: cp_space_bool_exp!
    ): cp_space_mutation_response
    "delete single row from the table: \"cp.space\""
    delete_cp_space_by_pk(id: uuid!): cp_space
    "delete data from the table: \"cp.visit\""
    delete_cp_visit(
        "filter the rows which have to be deleted"
        where: cp_visit_bool_exp!
    ): cp_visit_mutation_response
    "delete single row from the table: \"cp.visit\""
    delete_cp_visit_by_pk(id: uuid!): cp_visit
    "delete data from the table: \"cp.visit_note\""
    delete_cp_visit_note(
        "filter the rows which have to be deleted"
        where: cp_visit_note_bool_exp!
    ): cp_visit_note_mutation_response
    "delete single row from the table: \"cp.visit_note\""
    delete_cp_visit_note_by_pk(id: uuid!): cp_visit_note
    "delete data from the table: \"lookup.app_notification_type\""
    delete_lookup_app_notification_type(
        "filter the rows which have to be deleted"
        where: lookup_app_notification_type_bool_exp!
    ): lookup_app_notification_type_mutation_response
    "delete single row from the table: \"lookup.app_notification_type\""
    delete_lookup_app_notification_type_by_pk(value: String!): lookup_app_notification_type
    "delete data from the table: \"lookup.cms_content_block_type\""
    delete_lookup_cms_content_block_type(
        "filter the rows which have to be deleted"
        where: lookup_cms_content_block_type_bool_exp!
    ): lookup_cms_content_block_type_mutation_response
    "delete single row from the table: \"lookup.cms_content_block_type\""
    delete_lookup_cms_content_block_type_by_pk(value: String!): lookup_cms_content_block_type
    "delete data from the table: \"lookup.cms_content_type\""
    delete_lookup_cms_content_type(
        "filter the rows which have to be deleted"
        where: lookup_cms_content_type_bool_exp!
    ): lookup_cms_content_type_mutation_response
    "delete single row from the table: \"lookup.cms_content_type\""
    delete_lookup_cms_content_type_by_pk(value: String!): lookup_cms_content_type
    "delete data from the table: \"lookup.cp_visit_status\""
    delete_lookup_cp_visit_status(
        "filter the rows which have to be deleted"
        where: lookup_cp_visit_status_bool_exp!
    ): lookup_cp_visit_status_mutation_response
    "delete single row from the table: \"lookup.cp_visit_status\""
    delete_lookup_cp_visit_status_by_pk(value: String!): lookup_cp_visit_status
    "delete data from the table: \"lookup.schema_audience_type\""
    delete_lookup_schema_audience_type(
        "filter the rows which have to be deleted"
        where: lookup_schema_audience_type_bool_exp!
    ): lookup_schema_audience_type_mutation_response
    "delete single row from the table: \"lookup.schema_audience_type\""
    delete_lookup_schema_audience_type_by_pk(value: String!): lookup_schema_audience_type
    "delete data from the table: \"object.file\""
    delete_object_file(
        "filter the rows which have to be deleted"
        where: object_file_bool_exp!
    ): object_file_mutation_response
    "delete single row from the table: \"object.file\""
    delete_object_file_by_pk(id: String!): object_file
    "delete data from the table: \"object.ie\""
    delete_object_ie(
        "filter the rows which have to be deleted"
        where: object_ie_bool_exp!
    ): object_ie_mutation_response
    "delete single row from the table: \"object.ie\""
    delete_object_ie_by_pk(
        "de unieke fragmentid in mediahaven"
        meemoo_fragment_id: String!
    ): object_ie
    "delete data from the table: \"object.representation\""
    delete_object_representation(
        "filter the rows which have to be deleted"
        where: object_representation_bool_exp!
    ): object_representation_mutation_response
    "delete single row from the table: \"object.representation\""
    delete_object_representation_by_pk(id: String!): object_representation
    "delete data from the table: \"sync.audio\""
    delete_sync_audio(
        "filter the rows which have to be deleted"
        where: sync_audio_bool_exp!
    ): sync_audio_mutation_response
    "delete single row from the table: \"sync.audio\""
    delete_sync_audio_by_pk(
        "De meest unieke key: de mediafragment ID uit Mediahaven"
        meemoo_fragment_id: String!
    ): sync_audio
    "delete data from the table: \"sync.film\""
    delete_sync_film(
        "filter the rows which have to be deleted"
        where: sync_film_bool_exp!
    ): sync_film_mutation_response
    "delete single row from the table: \"sync.film\""
    delete_sync_film_by_pk(
        "De meest unieke key: de mediafragment ID uit Mediahaven"
        meemoo_fragment_id: String!
    ): sync_film
    "delete data from the table: \"sync.video\""
    delete_sync_video(
        "filter the rows which have to be deleted"
        where: sync_video_bool_exp!
    ): sync_video_mutation_response
    "delete single row from the table: \"sync.video\""
    delete_sync_video_by_pk(
        "De meest unieke key: de mediafragment ID uit Mediahaven"
        meemoo_fragment_id: String!
    ): sync_video
    "delete data from the table: \"users.collection\""
    delete_users_collection(
        "filter the rows which have to be deleted"
        where: users_collection_bool_exp!
    ): users_collection_mutation_response
    "delete single row from the table: \"users.collection\""
    delete_users_collection_by_pk(id: uuid!): users_collection
    "delete data from the table: \"users.collection_ie\""
    delete_users_collection_ie(
        "filter the rows which have to be deleted"
        where: users_collection_ie_bool_exp!
    ): users_collection_ie_mutation_response
    "delete single row from the table: \"users.collection_ie\""
    delete_users_collection_ie_by_pk(object_ie_meemoo_fragment_id: String!, user_collection_id: uuid!): users_collection_ie
    "delete data from the table: \"users.group\""
    delete_users_group(
        "filter the rows which have to be deleted"
        where: users_group_bool_exp!
    ): users_group_mutation_response
    "delete single row from the table: \"users.group\""
    delete_users_group_by_pk(id: uuid!): users_group
    "delete data from the table: \"users.group_permission\""
    delete_users_group_permission(
        "filter the rows which have to be deleted"
        where: users_group_permission_bool_exp!
    ): users_group_permission_mutation_response
    "delete single row from the table: \"users.group_permission\""
    delete_users_group_permission_by_pk(id: uuid!): users_group_permission
    "delete data from the table: \"users.identity\""
    delete_users_identity(
        "filter the rows which have to be deleted"
        where: users_identity_bool_exp!
    ): users_identity_mutation_response
    "delete single row from the table: \"users.identity\""
    delete_users_identity_by_pk(id: uuid!): users_identity
    "delete data from the table: \"users.identity_provider\""
    delete_users_identity_provider(
        "filter the rows which have to be deleted"
        where: users_identity_provider_bool_exp!
    ): users_identity_provider_mutation_response
    "delete single row from the table: \"users.identity_provider\""
    delete_users_identity_provider_by_pk(name: String!): users_identity_provider
    "delete data from the table: \"users.permission\""
    delete_users_permission(
        "filter the rows which have to be deleted"
        where: users_permission_bool_exp!
    ): users_permission_mutation_response
    "delete single row from the table: \"users.permission\""
    delete_users_permission_by_pk(id: uuid!): users_permission
    "delete data from the table: \"users.profile\""
    delete_users_profile(
        "filter the rows which have to be deleted"
        where: users_profile_bool_exp!
    ): users_profile_mutation_response
    "delete single row from the table: \"users.profile\""
    delete_users_profile_by_pk(id: uuid!): users_profile
    "insert data into the table: \"app.notification\""
    insert_app_notification(
        "the rows to be inserted"
        objects: [app_notification_insert_input!]!,
        "on conflict condition"
        on_conflict: app_notification_on_conflict
    ): app_notification_mutation_response
    "insert a single row into the table: \"app.notification\""
    insert_app_notification_one(
        "the row to be inserted"
        object: app_notification_insert_input!,
        "on conflict condition"
        on_conflict: app_notification_on_conflict
    ): app_notification
    "insert data into the table: \"cms.content\""
    insert_cms_content(
        "the rows to be inserted"
        objects: [cms_content_insert_input!]!,
        "on conflict condition"
        on_conflict: cms_content_on_conflict
    ): cms_content_mutation_response
    "insert data into the table: \"cms.content_blocks\""
    insert_cms_content_blocks(
        "the rows to be inserted"
        objects: [cms_content_blocks_insert_input!]!,
        "on conflict condition"
        on_conflict: cms_content_blocks_on_conflict
    ): cms_content_blocks_mutation_response
    "insert a single row into the table: \"cms.content_blocks\""
    insert_cms_content_blocks_one(
        "the row to be inserted"
        object: cms_content_blocks_insert_input!,
        "on conflict condition"
        on_conflict: cms_content_blocks_on_conflict
    ): cms_content_blocks
    "insert data into the table: \"cms.content_content_labels\""
    insert_cms_content_content_labels(
        "the rows to be inserted"
        objects: [cms_content_content_labels_insert_input!]!,
        "on conflict condition"
        on_conflict: cms_content_content_labels_on_conflict
    ): cms_content_content_labels_mutation_response
    "insert a single row into the table: \"cms.content_content_labels\""
    insert_cms_content_content_labels_one(
        "the row to be inserted"
        object: cms_content_content_labels_insert_input!,
        "on conflict condition"
        on_conflict: cms_content_content_labels_on_conflict
    ): cms_content_content_labels
    "insert data into the table: \"cms.content_labels\""
    insert_cms_content_labels(
        "the rows to be inserted"
        objects: [cms_content_labels_insert_input!]!,
        "on conflict condition"
        on_conflict: cms_content_labels_on_conflict
    ): cms_content_labels_mutation_response
    "insert a single row into the table: \"cms.content_labels\""
    insert_cms_content_labels_one(
        "the row to be inserted"
        object: cms_content_labels_insert_input!,
        "on conflict condition"
        on_conflict: cms_content_labels_on_conflict
    ): cms_content_labels
    "insert a single row into the table: \"cms.content\""
    insert_cms_content_one(
        "the row to be inserted"
        object: cms_content_insert_input!,
        "on conflict condition"
        on_conflict: cms_content_on_conflict
    ): cms_content
    "insert data into the table: \"cms.navigation_element\""
    insert_cms_navigation_element(
        "the rows to be inserted"
        objects: [cms_navigation_element_insert_input!]!,
        "on conflict condition"
        on_conflict: cms_navigation_element_on_conflict
    ): cms_navigation_element_mutation_response
    "insert a single row into the table: \"cms.navigation_element\""
    insert_cms_navigation_element_one(
        "the row to be inserted"
        object: cms_navigation_element_insert_input!,
        "on conflict condition"
        on_conflict: cms_navigation_element_on_conflict
    ): cms_navigation_element
    "insert data into the table: \"cms.site_variables\""
    insert_cms_site_variables(
        "the rows to be inserted"
        objects: [cms_site_variables_insert_input!]!,
        "on conflict condition"
        on_conflict: cms_site_variables_on_conflict
    ): cms_site_variables_mutation_response
    "insert a single row into the table: \"cms.site_variables\""
    insert_cms_site_variables_one(
        "the row to be inserted"
        object: cms_site_variables_insert_input!,
        "on conflict condition"
        on_conflict: cms_site_variables_on_conflict
    ): cms_site_variables
    "insert data into the table: \"cp.index\""
    insert_cp_index(
        "the rows to be inserted"
        objects: [cp_index_insert_input!]!,
        "on conflict condition"
        on_conflict: cp_index_on_conflict
    ): cp_index_mutation_response
    "insert a single row into the table: \"cp.index\""
    insert_cp_index_one(
        "the row to be inserted"
        object: cp_index_insert_input!,
        "on conflict condition"
        on_conflict: cp_index_on_conflict
    ): cp_index
    "insert data into the table: \"cp.maintainer\""
    insert_cp_maintainer(
        "the rows to be inserted"
        objects: [cp_maintainer_insert_input!]!,
        "on conflict condition"
        on_conflict: cp_maintainer_on_conflict
    ): cp_maintainer_mutation_response
    "insert a single row into the table: \"cp.maintainer\""
    insert_cp_maintainer_one(
        "the row to be inserted"
        object: cp_maintainer_insert_input!,
        "on conflict condition"
        on_conflict: cp_maintainer_on_conflict
    ): cp_maintainer
    "insert data into the table: \"cp.maintainer_users_profile\""
    insert_cp_maintainer_users_profile(
        "the rows to be inserted"
        objects: [cp_maintainer_users_profile_insert_input!]!,
        "on conflict condition"
        on_conflict: cp_maintainer_users_profile_on_conflict
    ): cp_maintainer_users_profile_mutation_response
    "insert a single row into the table: \"cp.maintainer_users_profile\""
    insert_cp_maintainer_users_profile_one(
        "the row to be inserted"
        object: cp_maintainer_users_profile_insert_input!,
        "on conflict condition"
        on_conflict: cp_maintainer_users_profile_on_conflict
    ): cp_maintainer_users_profile
    "insert data into the table: \"cp.space\""
    insert_cp_space(
        "the rows to be inserted"
        objects: [cp_space_insert_input!]!,
        "on conflict condition"
        on_conflict: cp_space_on_conflict
    ): cp_space_mutation_response
    "insert a single row into the table: \"cp.space\""
    insert_cp_space_one(
        "the row to be inserted"
        object: cp_space_insert_input!,
        "on conflict condition"
        on_conflict: cp_space_on_conflict
    ): cp_space
    "insert data into the table: \"cp.visit\""
    insert_cp_visit(
        "the rows to be inserted"
        objects: [cp_visit_insert_input!]!,
        "on conflict condition"
        on_conflict: cp_visit_on_conflict
    ): cp_visit_mutation_response
    "insert data into the table: \"cp.visit_note\""
    insert_cp_visit_note(
        "the rows to be inserted"
        objects: [cp_visit_note_insert_input!]!,
        "on conflict condition"
        on_conflict: cp_visit_note_on_conflict
    ): cp_visit_note_mutation_response
    "insert a single row into the table: \"cp.visit_note\""
    insert_cp_visit_note_one(
        "the row to be inserted"
        object: cp_visit_note_insert_input!,
        "on conflict condition"
        on_conflict: cp_visit_note_on_conflict
    ): cp_visit_note
    "insert a single row into the table: \"cp.visit\""
    insert_cp_visit_one(
        "the row to be inserted"
        object: cp_visit_insert_input!,
        "on conflict condition"
        on_conflict: cp_visit_on_conflict
    ): cp_visit
    "insert data into the table: \"lookup.app_notification_type\""
    insert_lookup_app_notification_type(
        "the rows to be inserted"
        objects: [lookup_app_notification_type_insert_input!]!,
        "on conflict condition"
        on_conflict: lookup_app_notification_type_on_conflict
    ): lookup_app_notification_type_mutation_response
    "insert a single row into the table: \"lookup.app_notification_type\""
    insert_lookup_app_notification_type_one(
        "the row to be inserted"
        object: lookup_app_notification_type_insert_input!,
        "on conflict condition"
        on_conflict: lookup_app_notification_type_on_conflict
    ): lookup_app_notification_type
    "insert data into the table: \"lookup.cms_content_block_type\""
    insert_lookup_cms_content_block_type(
        "the rows to be inserted"
        objects: [lookup_cms_content_block_type_insert_input!]!,
        "on conflict condition"
        on_conflict: lookup_cms_content_block_type_on_conflict
    ): lookup_cms_content_block_type_mutation_response
    "insert a single row into the table: \"lookup.cms_content_block_type\""
    insert_lookup_cms_content_block_type_one(
        "the row to be inserted"
        object: lookup_cms_content_block_type_insert_input!,
        "on conflict condition"
        on_conflict: lookup_cms_content_block_type_on_conflict
    ): lookup_cms_content_block_type
    "insert data into the table: \"lookup.cms_content_type\""
    insert_lookup_cms_content_type(
        "the rows to be inserted"
        objects: [lookup_cms_content_type_insert_input!]!,
        "on conflict condition"
        on_conflict: lookup_cms_content_type_on_conflict
    ): lookup_cms_content_type_mutation_response
    "insert a single row into the table: \"lookup.cms_content_type\""
    insert_lookup_cms_content_type_one(
        "the row to be inserted"
        object: lookup_cms_content_type_insert_input!,
        "on conflict condition"
        on_conflict: lookup_cms_content_type_on_conflict
    ): lookup_cms_content_type
    "insert data into the table: \"lookup.cp_visit_status\""
    insert_lookup_cp_visit_status(
        "the rows to be inserted"
        objects: [lookup_cp_visit_status_insert_input!]!,
        "on conflict condition"
        on_conflict: lookup_cp_visit_status_on_conflict
    ): lookup_cp_visit_status_mutation_response
    "insert a single row into the table: \"lookup.cp_visit_status\""
    insert_lookup_cp_visit_status_one(
        "the row to be inserted"
        object: lookup_cp_visit_status_insert_input!,
        "on conflict condition"
        on_conflict: lookup_cp_visit_status_on_conflict
    ): lookup_cp_visit_status
    "insert data into the table: \"lookup.schema_audience_type\""
    insert_lookup_schema_audience_type(
        "the rows to be inserted"
        objects: [lookup_schema_audience_type_insert_input!]!,
        "on conflict condition"
        on_conflict: lookup_schema_audience_type_on_conflict
    ): lookup_schema_audience_type_mutation_response
    "insert a single row into the table: \"lookup.schema_audience_type\""
    insert_lookup_schema_audience_type_one(
        "the row to be inserted"
        object: lookup_schema_audience_type_insert_input!,
        "on conflict condition"
        on_conflict: lookup_schema_audience_type_on_conflict
    ): lookup_schema_audience_type
    "insert data into the table: \"object.file\""
    insert_object_file(
        "the rows to be inserted"
        objects: [object_file_insert_input!]!,
        "on conflict condition"
        on_conflict: object_file_on_conflict
    ): object_file_mutation_response
    "insert a single row into the table: \"object.file\""
    insert_object_file_one(
        "the row to be inserted"
        object: object_file_insert_input!,
        "on conflict condition"
        on_conflict: object_file_on_conflict
    ): object_file
    "insert data into the table: \"object.ie\""
    insert_object_ie(
        "the rows to be inserted"
        objects: [object_ie_insert_input!]!,
        "on conflict condition"
        on_conflict: object_ie_on_conflict
    ): object_ie_mutation_response
    "insert a single row into the table: \"object.ie\""
    insert_object_ie_one(
        "the row to be inserted"
        object: object_ie_insert_input!,
        "on conflict condition"
        on_conflict: object_ie_on_conflict
    ): object_ie
    "insert data into the table: \"object.representation\""
    insert_object_representation(
        "the rows to be inserted"
        objects: [object_representation_insert_input!]!,
        "on conflict condition"
        on_conflict: object_representation_on_conflict
    ): object_representation_mutation_response
    "insert a single row into the table: \"object.representation\""
    insert_object_representation_one(
        "the row to be inserted"
        object: object_representation_insert_input!,
        "on conflict condition"
        on_conflict: object_representation_on_conflict
    ): object_representation
    "insert data into the table: \"sync.audio\""
    insert_sync_audio(
        "the rows to be inserted"
        objects: [sync_audio_insert_input!]!,
        "on conflict condition"
        on_conflict: sync_audio_on_conflict
    ): sync_audio_mutation_response
    "insert a single row into the table: \"sync.audio\""
    insert_sync_audio_one(
        "the row to be inserted"
        object: sync_audio_insert_input!,
        "on conflict condition"
        on_conflict: sync_audio_on_conflict
    ): sync_audio
    "insert data into the table: \"sync.film\""
    insert_sync_film(
        "the rows to be inserted"
        objects: [sync_film_insert_input!]!,
        "on conflict condition"
        on_conflict: sync_film_on_conflict
    ): sync_film_mutation_response
    "insert a single row into the table: \"sync.film\""
    insert_sync_film_one(
        "the row to be inserted"
        object: sync_film_insert_input!,
        "on conflict condition"
        on_conflict: sync_film_on_conflict
    ): sync_film
    "insert data into the table: \"sync.video\""
    insert_sync_video(
        "the rows to be inserted"
        objects: [sync_video_insert_input!]!,
        "on conflict condition"
        on_conflict: sync_video_on_conflict
    ): sync_video_mutation_response
    "insert a single row into the table: \"sync.video\""
    insert_sync_video_one(
        "the row to be inserted"
        object: sync_video_insert_input!,
        "on conflict condition"
        on_conflict: sync_video_on_conflict
    ): sync_video
    "insert data into the table: \"users.collection\""
    insert_users_collection(
        "the rows to be inserted"
        objects: [users_collection_insert_input!]!,
        "on conflict condition"
        on_conflict: users_collection_on_conflict
    ): users_collection_mutation_response
    "insert data into the table: \"users.collection_ie\""
    insert_users_collection_ie(
        "the rows to be inserted"
        objects: [users_collection_ie_insert_input!]!,
        "on conflict condition"
        on_conflict: users_collection_ie_on_conflict
    ): users_collection_ie_mutation_response
    "insert a single row into the table: \"users.collection_ie\""
    insert_users_collection_ie_one(
        "the row to be inserted"
        object: users_collection_ie_insert_input!,
        "on conflict condition"
        on_conflict: users_collection_ie_on_conflict
    ): users_collection_ie
    "insert a single row into the table: \"users.collection\""
    insert_users_collection_one(
        "the row to be inserted"
        object: users_collection_insert_input!,
        "on conflict condition"
        on_conflict: users_collection_on_conflict
    ): users_collection
    "insert data into the table: \"users.group\""
    insert_users_group(
        "the rows to be inserted"
        objects: [users_group_insert_input!]!,
        "on conflict condition"
        on_conflict: users_group_on_conflict
    ): users_group_mutation_response
    "insert a single row into the table: \"users.group\""
    insert_users_group_one(
        "the row to be inserted"
        object: users_group_insert_input!,
        "on conflict condition"
        on_conflict: users_group_on_conflict
    ): users_group
    "insert data into the table: \"users.group_permission\""
    insert_users_group_permission(
        "the rows to be inserted"
        objects: [users_group_permission_insert_input!]!,
        "on conflict condition"
        on_conflict: users_group_permission_on_conflict
    ): users_group_permission_mutation_response
    "insert a single row into the table: \"users.group_permission\""
    insert_users_group_permission_one(
        "the row to be inserted"
        object: users_group_permission_insert_input!,
        "on conflict condition"
        on_conflict: users_group_permission_on_conflict
    ): users_group_permission
    "insert data into the table: \"users.identity\""
    insert_users_identity(
        "the rows to be inserted"
        objects: [users_identity_insert_input!]!,
        "on conflict condition"
        on_conflict: users_identity_on_conflict
    ): users_identity_mutation_response
    "insert a single row into the table: \"users.identity\""
    insert_users_identity_one(
        "the row to be inserted"
        object: users_identity_insert_input!,
        "on conflict condition"
        on_conflict: users_identity_on_conflict
    ): users_identity
    "insert data into the table: \"users.identity_provider\""
    insert_users_identity_provider(
        "the rows to be inserted"
        objects: [users_identity_provider_insert_input!]!,
        "on conflict condition"
        on_conflict: users_identity_provider_on_conflict
    ): users_identity_provider_mutation_response
    "insert a single row into the table: \"users.identity_provider\""
    insert_users_identity_provider_one(
        "the row to be inserted"
        object: users_identity_provider_insert_input!,
        "on conflict condition"
        on_conflict: users_identity_provider_on_conflict
    ): users_identity_provider
    "insert data into the table: \"users.permission\""
    insert_users_permission(
        "the rows to be inserted"
        objects: [users_permission_insert_input!]!,
        "on conflict condition"
        on_conflict: users_permission_on_conflict
    ): users_permission_mutation_response
    "insert a single row into the table: \"users.permission\""
    insert_users_permission_one(
        "the row to be inserted"
        object: users_permission_insert_input!,
        "on conflict condition"
        on_conflict: users_permission_on_conflict
    ): users_permission
    "insert data into the table: \"users.profile\""
    insert_users_profile(
        "the rows to be inserted"
        objects: [users_profile_insert_input!]!,
        "on conflict condition"
        on_conflict: users_profile_on_conflict
    ): users_profile_mutation_response
    "insert a single row into the table: \"users.profile\""
    insert_users_profile_one(
        "the row to be inserted"
        object: users_profile_insert_input!,
        "on conflict condition"
        on_conflict: users_profile_on_conflict
    ): users_profile
    "update data of the table: \"app.notification\""
    update_app_notification(
        "sets the columns of the filtered rows to the given values"
        _set: app_notification_set_input,
        "filter the rows which have to be updated"
        where: app_notification_bool_exp!
    ): app_notification_mutation_response
    "update single row of the table: \"app.notification\""
    update_app_notification_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: app_notification_set_input,
        pk_columns: app_notification_pk_columns_input!
    ): app_notification
    "update data of the table: \"cms.content\""
    update_cms_content(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: cms_content_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: cms_content_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: cms_content_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: cms_content_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: cms_content_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: cms_content_set_input,
        "filter the rows which have to be updated"
        where: cms_content_bool_exp!
    ): cms_content_mutation_response
    "update data of the table: \"cms.content_blocks\""
    update_cms_content_blocks(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: cms_content_blocks_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: cms_content_blocks_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: cms_content_blocks_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: cms_content_blocks_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: cms_content_blocks_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: cms_content_blocks_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: cms_content_blocks_set_input,
        "filter the rows which have to be updated"
        where: cms_content_blocks_bool_exp!
    ): cms_content_blocks_mutation_response
    "update single row of the table: \"cms.content_blocks\""
    update_cms_content_blocks_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: cms_content_blocks_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: cms_content_blocks_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: cms_content_blocks_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: cms_content_blocks_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: cms_content_blocks_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: cms_content_blocks_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: cms_content_blocks_set_input,
        pk_columns: cms_content_blocks_pk_columns_input!
    ): cms_content_blocks
    "update single row of the table: \"cms.content\""
    update_cms_content_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: cms_content_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: cms_content_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: cms_content_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: cms_content_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: cms_content_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: cms_content_set_input,
        pk_columns: cms_content_pk_columns_input!
    ): cms_content
    "update data of the table: \"cms.content_content_labels\""
    update_cms_content_content_labels(
        "sets the columns of the filtered rows to the given values"
        _set: cms_content_content_labels_set_input,
        "filter the rows which have to be updated"
        where: cms_content_content_labels_bool_exp!
    ): cms_content_content_labels_mutation_response
    "update single row of the table: \"cms.content_content_labels\""
    update_cms_content_content_labels_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: cms_content_content_labels_set_input,
        pk_columns: cms_content_content_labels_pk_columns_input!
    ): cms_content_content_labels
    "update data of the table: \"cms.content_labels\""
    update_cms_content_labels(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: cms_content_labels_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: cms_content_labels_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: cms_content_labels_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: cms_content_labels_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: cms_content_labels_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: cms_content_labels_set_input,
        "filter the rows which have to be updated"
        where: cms_content_labels_bool_exp!
    ): cms_content_labels_mutation_response
    "update single row of the table: \"cms.content_labels\""
    update_cms_content_labels_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: cms_content_labels_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: cms_content_labels_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: cms_content_labels_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: cms_content_labels_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: cms_content_labels_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: cms_content_labels_set_input,
        pk_columns: cms_content_labels_pk_columns_input!
    ): cms_content_labels
    "update data of the table: \"cms.navigation_element\""
    update_cms_navigation_element(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: cms_navigation_element_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: cms_navigation_element_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: cms_navigation_element_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: cms_navigation_element_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: cms_navigation_element_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: cms_navigation_element_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: cms_navigation_element_set_input,
        "filter the rows which have to be updated"
        where: cms_navigation_element_bool_exp!
    ): cms_navigation_element_mutation_response
    "update single row of the table: \"cms.navigation_element\""
    update_cms_navigation_element_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: cms_navigation_element_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: cms_navigation_element_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: cms_navigation_element_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: cms_navigation_element_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: cms_navigation_element_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: cms_navigation_element_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: cms_navigation_element_set_input,
        pk_columns: cms_navigation_element_pk_columns_input!
    ): cms_navigation_element
    "update data of the table: \"cms.site_variables\""
    update_cms_site_variables(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: cms_site_variables_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: cms_site_variables_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: cms_site_variables_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: cms_site_variables_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: cms_site_variables_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: cms_site_variables_set_input,
        "filter the rows which have to be updated"
        where: cms_site_variables_bool_exp!
    ): cms_site_variables_mutation_response
    "update single row of the table: \"cms.site_variables\""
    update_cms_site_variables_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: cms_site_variables_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: cms_site_variables_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: cms_site_variables_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: cms_site_variables_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: cms_site_variables_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: cms_site_variables_set_input,
        pk_columns: cms_site_variables_pk_columns_input!
    ): cms_site_variables
    "update data of the table: \"cp.index\""
    update_cp_index(
        "sets the columns of the filtered rows to the given values"
        _set: cp_index_set_input,
        "filter the rows which have to be updated"
        where: cp_index_bool_exp!
    ): cp_index_mutation_response
    "update single row of the table: \"cp.index\""
    update_cp_index_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: cp_index_set_input,
        pk_columns: cp_index_pk_columns_input!
    ): cp_index
    "update data of the table: \"cp.maintainer\""
    update_cp_maintainer(
        "sets the columns of the filtered rows to the given values"
        _set: cp_maintainer_set_input,
        "filter the rows which have to be updated"
        where: cp_maintainer_bool_exp!
    ): cp_maintainer_mutation_response
    "update single row of the table: \"cp.maintainer\""
    update_cp_maintainer_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: cp_maintainer_set_input,
        pk_columns: cp_maintainer_pk_columns_input!
    ): cp_maintainer
    "update data of the table: \"cp.maintainer_users_profile\""
    update_cp_maintainer_users_profile(
        "sets the columns of the filtered rows to the given values"
        _set: cp_maintainer_users_profile_set_input,
        "filter the rows which have to be updated"
        where: cp_maintainer_users_profile_bool_exp!
    ): cp_maintainer_users_profile_mutation_response
    "update single row of the table: \"cp.maintainer_users_profile\""
    update_cp_maintainer_users_profile_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: cp_maintainer_users_profile_set_input,
        pk_columns: cp_maintainer_users_profile_pk_columns_input!
    ): cp_maintainer_users_profile
    "update data of the table: \"cp.space\""
    update_cp_space(
        "sets the columns of the filtered rows to the given values"
        _set: cp_space_set_input,
        "filter the rows which have to be updated"
        where: cp_space_bool_exp!
    ): cp_space_mutation_response
    "update single row of the table: \"cp.space\""
    update_cp_space_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: cp_space_set_input,
        pk_columns: cp_space_pk_columns_input!
    ): cp_space
    "update data of the table: \"cp.visit\""
    update_cp_visit(
        "sets the columns of the filtered rows to the given values"
        _set: cp_visit_set_input,
        "filter the rows which have to be updated"
        where: cp_visit_bool_exp!
    ): cp_visit_mutation_response
    "update single row of the table: \"cp.visit\""
    update_cp_visit_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: cp_visit_set_input,
        pk_columns: cp_visit_pk_columns_input!
    ): cp_visit
    "update data of the table: \"cp.visit_note\""
    update_cp_visit_note(
        "sets the columns of the filtered rows to the given values"
        _set: cp_visit_note_set_input,
        "filter the rows which have to be updated"
        where: cp_visit_note_bool_exp!
    ): cp_visit_note_mutation_response
    "update single row of the table: \"cp.visit_note\""
    update_cp_visit_note_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: cp_visit_note_set_input,
        pk_columns: cp_visit_note_pk_columns_input!
    ): cp_visit_note
    "update data of the table: \"lookup.app_notification_type\""
    update_lookup_app_notification_type(
        "sets the columns of the filtered rows to the given values"
        _set: lookup_app_notification_type_set_input,
        "filter the rows which have to be updated"
        where: lookup_app_notification_type_bool_exp!
    ): lookup_app_notification_type_mutation_response
    "update single row of the table: \"lookup.app_notification_type\""
    update_lookup_app_notification_type_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: lookup_app_notification_type_set_input,
        pk_columns: lookup_app_notification_type_pk_columns_input!
    ): lookup_app_notification_type
    "update data of the table: \"lookup.cms_content_block_type\""
    update_lookup_cms_content_block_type(
        "sets the columns of the filtered rows to the given values"
        _set: lookup_cms_content_block_type_set_input,
        "filter the rows which have to be updated"
        where: lookup_cms_content_block_type_bool_exp!
    ): lookup_cms_content_block_type_mutation_response
    "update single row of the table: \"lookup.cms_content_block_type\""
    update_lookup_cms_content_block_type_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: lookup_cms_content_block_type_set_input,
        pk_columns: lookup_cms_content_block_type_pk_columns_input!
    ): lookup_cms_content_block_type
    "update data of the table: \"lookup.cms_content_type\""
    update_lookup_cms_content_type(
        "sets the columns of the filtered rows to the given values"
        _set: lookup_cms_content_type_set_input,
        "filter the rows which have to be updated"
        where: lookup_cms_content_type_bool_exp!
    ): lookup_cms_content_type_mutation_response
    "update single row of the table: \"lookup.cms_content_type\""
    update_lookup_cms_content_type_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: lookup_cms_content_type_set_input,
        pk_columns: lookup_cms_content_type_pk_columns_input!
    ): lookup_cms_content_type
    "update data of the table: \"lookup.cp_visit_status\""
    update_lookup_cp_visit_status(
        "sets the columns of the filtered rows to the given values"
        _set: lookup_cp_visit_status_set_input,
        "filter the rows which have to be updated"
        where: lookup_cp_visit_status_bool_exp!
    ): lookup_cp_visit_status_mutation_response
    "update single row of the table: \"lookup.cp_visit_status\""
    update_lookup_cp_visit_status_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: lookup_cp_visit_status_set_input,
        pk_columns: lookup_cp_visit_status_pk_columns_input!
    ): lookup_cp_visit_status
    "update data of the table: \"lookup.schema_audience_type\""
    update_lookup_schema_audience_type(
        "sets the columns of the filtered rows to the given values"
        _set: lookup_schema_audience_type_set_input,
        "filter the rows which have to be updated"
        where: lookup_schema_audience_type_bool_exp!
    ): lookup_schema_audience_type_mutation_response
    "update single row of the table: \"lookup.schema_audience_type\""
    update_lookup_schema_audience_type_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: lookup_schema_audience_type_set_input,
        pk_columns: lookup_schema_audience_type_pk_columns_input!
    ): lookup_schema_audience_type
    "update data of the table: \"object.file\""
    update_object_file(
        "sets the columns of the filtered rows to the given values"
        _set: object_file_set_input,
        "filter the rows which have to be updated"
        where: object_file_bool_exp!
    ): object_file_mutation_response
    "update single row of the table: \"object.file\""
    update_object_file_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: object_file_set_input,
        pk_columns: object_file_pk_columns_input!
    ): object_file
    "update data of the table: \"object.ie\""
    update_object_ie(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: object_ie_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: object_ie_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: object_ie_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: object_ie_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: object_ie_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: object_ie_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: object_ie_set_input,
        "filter the rows which have to be updated"
        where: object_ie_bool_exp!
    ): object_ie_mutation_response
    "update single row of the table: \"object.ie\""
    update_object_ie_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: object_ie_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: object_ie_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: object_ie_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: object_ie_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: object_ie_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: object_ie_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: object_ie_set_input,
        pk_columns: object_ie_pk_columns_input!
    ): object_ie
    "update data of the table: \"object.representation\""
    update_object_representation(
        "sets the columns of the filtered rows to the given values"
        _set: object_representation_set_input,
        "filter the rows which have to be updated"
        where: object_representation_bool_exp!
    ): object_representation_mutation_response
    "update single row of the table: \"object.representation\""
    update_object_representation_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: object_representation_set_input,
        pk_columns: object_representation_pk_columns_input!
    ): object_representation
    "update data of the table: \"sync.audio\""
    update_sync_audio(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: sync_audio_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: sync_audio_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: sync_audio_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: sync_audio_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: sync_audio_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: sync_audio_set_input,
        "filter the rows which have to be updated"
        where: sync_audio_bool_exp!
    ): sync_audio_mutation_response
    "update single row of the table: \"sync.audio\""
    update_sync_audio_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: sync_audio_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: sync_audio_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: sync_audio_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: sync_audio_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: sync_audio_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: sync_audio_set_input,
        pk_columns: sync_audio_pk_columns_input!
    ): sync_audio
    "update data of the table: \"sync.film\""
    update_sync_film(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: sync_film_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: sync_film_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: sync_film_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: sync_film_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: sync_film_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: sync_film_set_input,
        "filter the rows which have to be updated"
        where: sync_film_bool_exp!
    ): sync_film_mutation_response
    "update single row of the table: \"sync.film\""
    update_sync_film_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: sync_film_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: sync_film_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: sync_film_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: sync_film_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: sync_film_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: sync_film_set_input,
        pk_columns: sync_film_pk_columns_input!
    ): sync_film
    "update data of the table: \"sync.video\""
    update_sync_video(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: sync_video_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: sync_video_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: sync_video_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: sync_video_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: sync_video_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: sync_video_set_input,
        "filter the rows which have to be updated"
        where: sync_video_bool_exp!
    ): sync_video_mutation_response
    "update single row of the table: \"sync.video\""
    update_sync_video_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: sync_video_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: sync_video_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: sync_video_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: sync_video_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: sync_video_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: sync_video_set_input,
        pk_columns: sync_video_pk_columns_input!
    ): sync_video
    "update data of the table: \"users.collection\""
    update_users_collection(
        "sets the columns of the filtered rows to the given values"
        _set: users_collection_set_input,
        "filter the rows which have to be updated"
        where: users_collection_bool_exp!
    ): users_collection_mutation_response
    "update single row of the table: \"users.collection\""
    update_users_collection_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: users_collection_set_input,
        pk_columns: users_collection_pk_columns_input!
    ): users_collection
    "update data of the table: \"users.collection_ie\""
    update_users_collection_ie(
        "sets the columns of the filtered rows to the given values"
        _set: users_collection_ie_set_input,
        "filter the rows which have to be updated"
        where: users_collection_ie_bool_exp!
    ): users_collection_ie_mutation_response
    "update single row of the table: \"users.collection_ie\""
    update_users_collection_ie_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: users_collection_ie_set_input,
        pk_columns: users_collection_ie_pk_columns_input!
    ): users_collection_ie
    "update data of the table: \"users.group\""
    update_users_group(
        "sets the columns of the filtered rows to the given values"
        _set: users_group_set_input,
        "filter the rows which have to be updated"
        where: users_group_bool_exp!
    ): users_group_mutation_response
    "update single row of the table: \"users.group\""
    update_users_group_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: users_group_set_input,
        pk_columns: users_group_pk_columns_input!
    ): users_group
    "update data of the table: \"users.group_permission\""
    update_users_group_permission(
        "sets the columns of the filtered rows to the given values"
        _set: users_group_permission_set_input,
        "filter the rows which have to be updated"
        where: users_group_permission_bool_exp!
    ): users_group_permission_mutation_response
    "update single row of the table: \"users.group_permission\""
    update_users_group_permission_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: users_group_permission_set_input,
        pk_columns: users_group_permission_pk_columns_input!
    ): users_group_permission
    "update data of the table: \"users.identity\""
    update_users_identity(
        "sets the columns of the filtered rows to the given values"
        _set: users_identity_set_input,
        "filter the rows which have to be updated"
        where: users_identity_bool_exp!
    ): users_identity_mutation_response
    "update single row of the table: \"users.identity\""
    update_users_identity_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: users_identity_set_input,
        pk_columns: users_identity_pk_columns_input!
    ): users_identity
    "update data of the table: \"users.identity_provider\""
    update_users_identity_provider(
        "sets the columns of the filtered rows to the given values"
        _set: users_identity_provider_set_input,
        "filter the rows which have to be updated"
        where: users_identity_provider_bool_exp!
    ): users_identity_provider_mutation_response
    "update single row of the table: \"users.identity_provider\""
    update_users_identity_provider_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: users_identity_provider_set_input,
        pk_columns: users_identity_provider_pk_columns_input!
    ): users_identity_provider
    "update data of the table: \"users.permission\""
    update_users_permission(
        "sets the columns of the filtered rows to the given values"
        _set: users_permission_set_input,
        "filter the rows which have to be updated"
        where: users_permission_bool_exp!
    ): users_permission_mutation_response
    "update single row of the table: \"users.permission\""
    update_users_permission_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: users_permission_set_input,
        pk_columns: users_permission_pk_columns_input!
    ): users_permission
    "update data of the table: \"users.profile\""
    update_users_profile(
        "sets the columns of the filtered rows to the given values"
        _set: users_profile_set_input,
        "filter the rows which have to be updated"
        where: users_profile_bool_exp!
    ): users_profile_mutation_response
    "update single row of the table: \"users.profile\""
    update_users_profile_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: users_profile_set_input,
        pk_columns: users_profile_pk_columns_input!
    ): users_profile
}

"""

Bestanden die deel uitmaken van de representaties van ie's.


columns and relationships of "object.file"
"""
type object_file {
    ebucore_is_media_fragment_of: String
    ebucore_media_type: String!
    id: String!
    "An object relationship"
    premis_is_included_in: object_representation!
    representation_id: String!
    schema_alternate_name: String
    schema_description: String
    schema_embed_url: String
    schema_name: String
}

"aggregated selection of \"object.file\""
type object_file_aggregate {
    aggregate: object_file_aggregate_fields
    nodes: [object_file!]!
}

"aggregate fields of \"object.file\""
type object_file_aggregate_fields {
    count(columns: [object_file_select_column!], distinct: Boolean): Int!
    max: object_file_max_fields
    min: object_file_min_fields
}

"aggregate max on columns"
type object_file_max_fields {
    ebucore_is_media_fragment_of: String
    ebucore_media_type: String
    id: String
    representation_id: String
    schema_alternate_name: String
    schema_description: String
    schema_embed_url: String
    schema_name: String
}

"aggregate min on columns"
type object_file_min_fields {
    ebucore_is_media_fragment_of: String
    ebucore_media_type: String
    id: String
    representation_id: String
    schema_alternate_name: String
    schema_description: String
    schema_embed_url: String
    schema_name: String
}

"response of any mutation on the table \"object.file\""
type object_file_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [object_file!]!
}

"columns and relationships of \"object.ie\""
type object_ie {
    "An array relationship"
    collection_ies(
        "distinct select on columns"
        distinct_on: [users_collection_ie_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_collection_ie_order_by!],
        "filter the rows returned"
        where: users_collection_ie_bool_exp
    ): [users_collection_ie!]!
    "An aggregate relationship"
    collection_ies_aggregate(
        "distinct select on columns"
        distinct_on: [users_collection_ie_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_collection_ie_order_by!],
        "filter the rows returned"
        where: users_collection_ie_bool_exp
    ): users_collection_ie_aggregate!
    "Datum waarop de IE beschikbaar is gemaakt"
    dcterms_available: timestamp
    "De datum waarop de IE werd gemaakt in edtf"
    dcterms_created: String
    "Het mediatype: video, audio, beeld, document, ..."
    dcterms_format: String!
    "De datum waarop de IE werd uitgebracht in edtf"
    dcterms_issued: String
    dcterms_medium: String
    ebucore_object_type: String
    "An object relationship"
    maintainer: cp_maintainer
    "de unieke fragmentid in mediahaven"
    meemoo_fragment_id: String!
    meemoo_media_object_id: String
    meemoofilm_base: String
    meemoofilm_color: Boolean
    meemoofilm_contains_embedded_caption: Boolean
    meemoofilm_embeddedCaptionLanguage: String
    meemoofilm_image_or_sound: String
    "Overige lokale identifiers van de Content Partner (json)"
    premis_identifier(
        "JSON select path"
        path: String
    ): jsonb
    "Maakt deel uit van een andere IE"
    premis_is_part_of: String
    "An array relationship"
    premis_is_represented_by(
        "distinct select on columns"
        distinct_on: [object_representation_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_representation_order_by!],
        "filter the rows returned"
        where: object_representation_bool_exp
    ): [object_representation!]!
    "An aggregate relationship"
    premis_is_represented_by_aggregate(
        "distinct select on columns"
        distinct_on: [object_representation_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_representation_order_by!],
        "filter the rows returned"
        where: object_representation_bool_exp
    ): object_representation_aggregate!
    "Is verwant aan een andere IE"
    premis_relationship: String
    "De inhoudelijke samenvatting van de IE"
    schema_abstract: String
    "Personen die geacteerd of anderzijds deelgenomen hebben in de IE"
    schema_actor(
        "JSON select path"
        path: String
    ): jsonb
    "Een alternatieve titel of naam van de IE"
    schema_alternate_name: String
    "Personen die op een andere wijze hebben bijgedragen aan de IE"
    schema_contributor(
        "JSON select path"
        path: String
    ): jsonb
    "De naam of ID van de rechtenhoudende persoon of organisatie"
    schema_copyright_holder: String
    "Opmerkingen bij rechten en hergebruik"
    schema_copyright_notice: String
    "Personen die hebben bijgedragen aan de creatie van de IE, aka author"
    schema_creator(
        "JSON select path"
        path: String
    ): jsonb
    "Datum waarop de IE werd aangemaakt"
    schema_date_created: daterange
    schema_date_created_lower_bound: date
    "Datum waarop de IE voor het eerst werd uitgegeven, uitgezonden of vertoond"
    schema_date_published: date
    "Een korte omschrijving van de IE"
    schema_description: String
    schema_duration: time
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: Int
    schema_genre: _text
    "De meemoo identifier voor een IE"
    schema_identifier: String!
    "De taal of talen die in de IE gebruikt worden"
    schema_in_language: _text
    schema_is_part_of(
        "JSON select path"
        path: String
    ): jsonb
    "Tags of sleutelwoorden die de IE omschrijven"
    schema_keywords: _text
    "De meemoolicenties op de betreffende IE"
    schema_license(
        "JSON select path"
        path: String
    ): jsonb
    schema_maintainer(iri: String): [ContentPartner]
    "De ID van de beherende instelling of aanbieder van de IE, aka de CP (tbv relatie met org API v2)"
    schema_maintainer_id: String
    schema_maintainer_id_lower: String
    "De primaire titel van de IE"
    schema_name: String!
    "Aantal paginas van geschreven media"
    schema_number_of_pages: Int
    schema_part_of_archive: _text
    "Aflevering"
    schema_part_of_episode: _text
    "Seizoen"
    schema_part_of_season: _text
    "Serie"
    schema_part_of_series: _text
    "Persoon of organisatie die verantwoordelijk was voor de publicatie van de IE"
    schema_publisher(
        "JSON select path"
        path: String
    ): jsonb
    "Plaatsen of locaties waarover de IE handelt of betrekking op heeft"
    schema_spatial_coverage: _text
    "Datums, tijdstippen of periodes waarover de IE handelt of betrekking op heeft"
    schema_temporal_coverage: _text
    "Een URL naar een thumbnail of placeholder voor de IE"
    schema_thumbnail_url: String
    updated_at: timestamptz
}

"aggregated selection of \"object.ie\""
type object_ie_aggregate {
    aggregate: object_ie_aggregate_fields
    nodes: [object_ie!]!
}

"aggregate fields of \"object.ie\""
type object_ie_aggregate_fields {
    avg: object_ie_avg_fields
    count(columns: [object_ie_select_column!], distinct: Boolean): Int!
    max: object_ie_max_fields
    min: object_ie_min_fields
    stddev: object_ie_stddev_fields
    stddev_pop: object_ie_stddev_pop_fields
    stddev_samp: object_ie_stddev_samp_fields
    sum: object_ie_sum_fields
    var_pop: object_ie_var_pop_fields
    var_samp: object_ie_var_samp_fields
    variance: object_ie_variance_fields
}

"aggregate avg on columns"
type object_ie_avg_fields {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: Float
    "Aantal paginas van geschreven media"
    schema_number_of_pages: Float
}

"aggregate max on columns"
type object_ie_max_fields {
    "Datum waarop de IE beschikbaar is gemaakt"
    dcterms_available: timestamp
    "De datum waarop de IE werd gemaakt in edtf"
    dcterms_created: String
    "Het mediatype: video, audio, beeld, document, ..."
    dcterms_format: String
    "De datum waarop de IE werd uitgebracht in edtf"
    dcterms_issued: String
    dcterms_medium: String
    ebucore_object_type: String
    "de unieke fragmentid in mediahaven"
    meemoo_fragment_id: String
    meemoo_media_object_id: String
    meemoofilm_base: String
    meemoofilm_embeddedCaptionLanguage: String
    meemoofilm_image_or_sound: String
    "Maakt deel uit van een andere IE"
    premis_is_part_of: String
    "Is verwant aan een andere IE"
    premis_relationship: String
    "De inhoudelijke samenvatting van de IE"
    schema_abstract: String
    "Een alternatieve titel of naam van de IE"
    schema_alternate_name: String
    "De naam of ID van de rechtenhoudende persoon of organisatie"
    schema_copyright_holder: String
    "Opmerkingen bij rechten en hergebruik"
    schema_copyright_notice: String
    schema_date_created_lower_bound: date
    "Datum waarop de IE voor het eerst werd uitgegeven, uitgezonden of vertoond"
    schema_date_published: date
    "Een korte omschrijving van de IE"
    schema_description: String
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: Int
    "De meemoo identifier voor een IE"
    schema_identifier: String
    "De ID van de beherende instelling of aanbieder van de IE, aka de CP (tbv relatie met org API v2)"
    schema_maintainer_id: String
    schema_maintainer_id_lower: String
    "De primaire titel van de IE"
    schema_name: String
    "Aantal paginas van geschreven media"
    schema_number_of_pages: Int
    "Een URL naar een thumbnail of placeholder voor de IE"
    schema_thumbnail_url: String
    updated_at: timestamptz
}

"aggregate min on columns"
type object_ie_min_fields {
    "Datum waarop de IE beschikbaar is gemaakt"
    dcterms_available: timestamp
    "De datum waarop de IE werd gemaakt in edtf"
    dcterms_created: String
    "Het mediatype: video, audio, beeld, document, ..."
    dcterms_format: String
    "De datum waarop de IE werd uitgebracht in edtf"
    dcterms_issued: String
    dcterms_medium: String
    ebucore_object_type: String
    "de unieke fragmentid in mediahaven"
    meemoo_fragment_id: String
    meemoo_media_object_id: String
    meemoofilm_base: String
    meemoofilm_embeddedCaptionLanguage: String
    meemoofilm_image_or_sound: String
    "Maakt deel uit van een andere IE"
    premis_is_part_of: String
    "Is verwant aan een andere IE"
    premis_relationship: String
    "De inhoudelijke samenvatting van de IE"
    schema_abstract: String
    "Een alternatieve titel of naam van de IE"
    schema_alternate_name: String
    "De naam of ID van de rechtenhoudende persoon of organisatie"
    schema_copyright_holder: String
    "Opmerkingen bij rechten en hergebruik"
    schema_copyright_notice: String
    schema_date_created_lower_bound: date
    "Datum waarop de IE voor het eerst werd uitgegeven, uitgezonden of vertoond"
    schema_date_published: date
    "Een korte omschrijving van de IE"
    schema_description: String
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: Int
    "De meemoo identifier voor een IE"
    schema_identifier: String
    "De ID van de beherende instelling of aanbieder van de IE, aka de CP (tbv relatie met org API v2)"
    schema_maintainer_id: String
    schema_maintainer_id_lower: String
    "De primaire titel van de IE"
    schema_name: String
    "Aantal paginas van geschreven media"
    schema_number_of_pages: Int
    "Een URL naar een thumbnail of placeholder voor de IE"
    schema_thumbnail_url: String
    updated_at: timestamptz
}

"response of any mutation on the table \"object.ie\""
type object_ie_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [object_ie!]!
}

"aggregate stddev on columns"
type object_ie_stddev_fields {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: Float
    "Aantal paginas van geschreven media"
    schema_number_of_pages: Float
}

"aggregate stddev_pop on columns"
type object_ie_stddev_pop_fields {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: Float
    "Aantal paginas van geschreven media"
    schema_number_of_pages: Float
}

"aggregate stddev_samp on columns"
type object_ie_stddev_samp_fields {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: Float
    "Aantal paginas van geschreven media"
    schema_number_of_pages: Float
}

"aggregate sum on columns"
type object_ie_sum_fields {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: Int
    "Aantal paginas van geschreven media"
    schema_number_of_pages: Int
}

"aggregate var_pop on columns"
type object_ie_var_pop_fields {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: Float
    "Aantal paginas van geschreven media"
    schema_number_of_pages: Float
}

"aggregate var_samp on columns"
type object_ie_var_samp_fields {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: Float
    "Aantal paginas van geschreven media"
    schema_number_of_pages: Float
}

"aggregate variance on columns"
type object_ie_variance_fields {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: Float
    "Aantal paginas van geschreven media"
    schema_number_of_pages: Float
}

"""

de digitalRepresentation van de IE inclusief mediaResource


columns and relationships of "object.representation"
"""
type object_representation {
    "het bestandstype van de represenatatie, container"
    dcterms_format: String!
    id: String!
    "de FragmentId van de IE waarvan dit de representation is"
    ie_meemoo_fragment_id: String!
    "An array relationship"
    premis_includes(
        "distinct select on columns"
        distinct_on: [object_file_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_file_order_by!],
        "filter the rows returned"
        where: object_file_bool_exp
    ): [object_file!]!
    "An aggregate relationship"
    premis_includes_aggregate(
        "distinct select on columns"
        distinct_on: [object_file_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_file_order_by!],
        "filter the rows returned"
        where: object_file_bool_exp
    ): object_file_aggregate!
    "An object relationship"
    premis_represents: object_ie!
    "label"
    schema_alternate_name: String
    "datum waarop de resource van de representation werd aangemaakt"
    schema_date_created: timestamp
    "de optionele beschrijving van de representatie zelf"
    schema_description: String
    "filename aka PathToVideo"
    schema_name: String!
    "de geschreven neerslag van een IE zijn audio"
    schema_transcript: String
}

"aggregated selection of \"object.representation\""
type object_representation_aggregate {
    aggregate: object_representation_aggregate_fields
    nodes: [object_representation!]!
}

"aggregate fields of \"object.representation\""
type object_representation_aggregate_fields {
    count(columns: [object_representation_select_column!], distinct: Boolean): Int!
    max: object_representation_max_fields
    min: object_representation_min_fields
}

"aggregate max on columns"
type object_representation_max_fields {
    "het bestandstype van de represenatatie, container"
    dcterms_format: String
    id: String
    "de FragmentId van de IE waarvan dit de representation is"
    ie_meemoo_fragment_id: String
    "label"
    schema_alternate_name: String
    "datum waarop de resource van de representation werd aangemaakt"
    schema_date_created: timestamp
    "de optionele beschrijving van de representatie zelf"
    schema_description: String
    "filename aka PathToVideo"
    schema_name: String
    "de geschreven neerslag van een IE zijn audio"
    schema_transcript: String
}

"aggregate min on columns"
type object_representation_min_fields {
    "het bestandstype van de represenatatie, container"
    dcterms_format: String
    id: String
    "de FragmentId van de IE waarvan dit de representation is"
    ie_meemoo_fragment_id: String
    "label"
    schema_alternate_name: String
    "datum waarop de resource van de representation werd aangemaakt"
    schema_date_created: timestamp
    "de optionele beschrijving van de representatie zelf"
    schema_description: String
    "filename aka PathToVideo"
    schema_name: String
    "de geschreven neerslag van een IE zijn audio"
    schema_transcript: String
}

"response of any mutation on the table \"object.representation\""
type object_representation_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [object_representation!]!
}

type query_root {
    "fetch data from the table: \"app.notification\""
    app_notification(
        "distinct select on columns"
        distinct_on: [app_notification_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [app_notification_order_by!],
        "filter the rows returned"
        where: app_notification_bool_exp
    ): [app_notification!]!
    "fetch aggregated fields from the table: \"app.notification\""
    app_notification_aggregate(
        "distinct select on columns"
        distinct_on: [app_notification_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [app_notification_order_by!],
        "filter the rows returned"
        where: app_notification_bool_exp
    ): app_notification_aggregate!
    "fetch data from the table: \"app.notification\" using primary key columns"
    app_notification_by_pk(id: uuid!): app_notification
    "fetch data from the table: \"cms.content\""
    cms_content(
        "distinct select on columns"
        distinct_on: [cms_content_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_order_by!],
        "filter the rows returned"
        where: cms_content_bool_exp
    ): [cms_content!]!
    "fetch aggregated fields from the table: \"cms.content\""
    cms_content_aggregate(
        "distinct select on columns"
        distinct_on: [cms_content_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_order_by!],
        "filter the rows returned"
        where: cms_content_bool_exp
    ): cms_content_aggregate!
    "fetch data from the table: \"cms.content_blocks\""
    cms_content_blocks(
        "distinct select on columns"
        distinct_on: [cms_content_blocks_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_blocks_order_by!],
        "filter the rows returned"
        where: cms_content_blocks_bool_exp
    ): [cms_content_blocks!]!
    "fetch aggregated fields from the table: \"cms.content_blocks\""
    cms_content_blocks_aggregate(
        "distinct select on columns"
        distinct_on: [cms_content_blocks_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_blocks_order_by!],
        "filter the rows returned"
        where: cms_content_blocks_bool_exp
    ): cms_content_blocks_aggregate!
    "fetch data from the table: \"cms.content_blocks\" using primary key columns"
    cms_content_blocks_by_pk(id: uuid!): cms_content_blocks
    "fetch data from the table: \"cms.content\" using primary key columns"
    cms_content_by_pk(id: uuid!): cms_content
    "fetch data from the table: \"cms.content_content_labels\""
    cms_content_content_labels(
        "distinct select on columns"
        distinct_on: [cms_content_content_labels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_content_labels_order_by!],
        "filter the rows returned"
        where: cms_content_content_labels_bool_exp
    ): [cms_content_content_labels!]!
    "fetch aggregated fields from the table: \"cms.content_content_labels\""
    cms_content_content_labels_aggregate(
        "distinct select on columns"
        distinct_on: [cms_content_content_labels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_content_labels_order_by!],
        "filter the rows returned"
        where: cms_content_content_labels_bool_exp
    ): cms_content_content_labels_aggregate!
    "fetch data from the table: \"cms.content_content_labels\" using primary key columns"
    cms_content_content_labels_by_pk(id: uuid!): cms_content_content_labels
    "fetch data from the table: \"cms.content_labels\""
    cms_content_labels(
        "distinct select on columns"
        distinct_on: [cms_content_labels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_labels_order_by!],
        "filter the rows returned"
        where: cms_content_labels_bool_exp
    ): [cms_content_labels!]!
    "fetch aggregated fields from the table: \"cms.content_labels\""
    cms_content_labels_aggregate(
        "distinct select on columns"
        distinct_on: [cms_content_labels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_labels_order_by!],
        "filter the rows returned"
        where: cms_content_labels_bool_exp
    ): cms_content_labels_aggregate!
    "fetch data from the table: \"cms.content_labels\" using primary key columns"
    cms_content_labels_by_pk(id: uuid!): cms_content_labels
    "fetch data from the table: \"cms.navigation_element\""
    cms_navigation_element(
        "distinct select on columns"
        distinct_on: [cms_navigation_element_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_navigation_element_order_by!],
        "filter the rows returned"
        where: cms_navigation_element_bool_exp
    ): [cms_navigation_element!]!
    "fetch aggregated fields from the table: \"cms.navigation_element\""
    cms_navigation_element_aggregate(
        "distinct select on columns"
        distinct_on: [cms_navigation_element_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_navigation_element_order_by!],
        "filter the rows returned"
        where: cms_navigation_element_bool_exp
    ): cms_navigation_element_aggregate!
    "fetch data from the table: \"cms.navigation_element\" using primary key columns"
    cms_navigation_element_by_pk(id: uuid!): cms_navigation_element
    "fetch data from the table: \"cms.site_variables\""
    cms_site_variables(
        "distinct select on columns"
        distinct_on: [cms_site_variables_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_site_variables_order_by!],
        "filter the rows returned"
        where: cms_site_variables_bool_exp
    ): [cms_site_variables!]!
    "fetch aggregated fields from the table: \"cms.site_variables\""
    cms_site_variables_aggregate(
        "distinct select on columns"
        distinct_on: [cms_site_variables_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_site_variables_order_by!],
        "filter the rows returned"
        where: cms_site_variables_bool_exp
    ): cms_site_variables_aggregate!
    "fetch data from the table: \"cms.site_variables\" using primary key columns"
    cms_site_variables_by_pk(name: String!): cms_site_variables
    contentpartners(id: String, iri: String): [ContentPartner]
    "fetch data from the table: \"cp.index\""
    cp_index(
        "distinct select on columns"
        distinct_on: [cp_index_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_index_order_by!],
        "filter the rows returned"
        where: cp_index_bool_exp
    ): [cp_index!]!
    "fetch aggregated fields from the table: \"cp.index\""
    cp_index_aggregate(
        "distinct select on columns"
        distinct_on: [cp_index_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_index_order_by!],
        "filter the rows returned"
        where: cp_index_bool_exp
    ): cp_index_aggregate!
    "fetch data from the table: \"cp.index\" using primary key columns"
    cp_index_by_pk(schema_maintainer_id: String!): cp_index
    "fetch data from the table: \"cp.maintainer\""
    cp_maintainer(
        "distinct select on columns"
        distinct_on: [cp_maintainer_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_maintainer_order_by!],
        "filter the rows returned"
        where: cp_maintainer_bool_exp
    ): [cp_maintainer!]!
    "fetch aggregated fields from the table: \"cp.maintainer\""
    cp_maintainer_aggregate(
        "distinct select on columns"
        distinct_on: [cp_maintainer_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_maintainer_order_by!],
        "filter the rows returned"
        where: cp_maintainer_bool_exp
    ): cp_maintainer_aggregate!
    "fetch data from the table: \"cp.maintainer\" using primary key columns"
    cp_maintainer_by_pk(schema_identifier: String!): cp_maintainer
    "fetch data from the table: \"cp.maintainer_users_profile\""
    cp_maintainer_users_profile(
        "distinct select on columns"
        distinct_on: [cp_maintainer_users_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_maintainer_users_profile_order_by!],
        "filter the rows returned"
        where: cp_maintainer_users_profile_bool_exp
    ): [cp_maintainer_users_profile!]!
    "fetch aggregated fields from the table: \"cp.maintainer_users_profile\""
    cp_maintainer_users_profile_aggregate(
        "distinct select on columns"
        distinct_on: [cp_maintainer_users_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_maintainer_users_profile_order_by!],
        "filter the rows returned"
        where: cp_maintainer_users_profile_bool_exp
    ): cp_maintainer_users_profile_aggregate!
    "fetch data from the table: \"cp.maintainer_users_profile\" using primary key columns"
    cp_maintainer_users_profile_by_pk(id: uuid!): cp_maintainer_users_profile
    "fetch data from the table: \"cp.space\""
    cp_space(
        "distinct select on columns"
        distinct_on: [cp_space_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_space_order_by!],
        "filter the rows returned"
        where: cp_space_bool_exp
    ): [cp_space!]!
    "fetch aggregated fields from the table: \"cp.space\""
    cp_space_aggregate(
        "distinct select on columns"
        distinct_on: [cp_space_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_space_order_by!],
        "filter the rows returned"
        where: cp_space_bool_exp
    ): cp_space_aggregate!
    "fetch data from the table: \"cp.space\" using primary key columns"
    cp_space_by_pk(id: uuid!): cp_space
    "fetch data from the table: \"cp.visit\""
    cp_visit(
        "distinct select on columns"
        distinct_on: [cp_visit_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_order_by!],
        "filter the rows returned"
        where: cp_visit_bool_exp
    ): [cp_visit!]!
    "fetch aggregated fields from the table: \"cp.visit\""
    cp_visit_aggregate(
        "distinct select on columns"
        distinct_on: [cp_visit_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_order_by!],
        "filter the rows returned"
        where: cp_visit_bool_exp
    ): cp_visit_aggregate!
    "fetch data from the table: \"cp.visit\" using primary key columns"
    cp_visit_by_pk(id: uuid!): cp_visit
    "fetch data from the table: \"cp.visit_note\""
    cp_visit_note(
        "distinct select on columns"
        distinct_on: [cp_visit_note_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_note_order_by!],
        "filter the rows returned"
        where: cp_visit_note_bool_exp
    ): [cp_visit_note!]!
    "fetch aggregated fields from the table: \"cp.visit_note\""
    cp_visit_note_aggregate(
        "distinct select on columns"
        distinct_on: [cp_visit_note_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_note_order_by!],
        "filter the rows returned"
        where: cp_visit_note_bool_exp
    ): cp_visit_note_aggregate!
    "fetch data from the table: \"cp.visit_note\" using primary key columns"
    cp_visit_note_by_pk(id: uuid!): cp_visit_note
    "fetch data from the table: \"lookup.app_notification_type\""
    lookup_app_notification_type(
        "distinct select on columns"
        distinct_on: [lookup_app_notification_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_app_notification_type_order_by!],
        "filter the rows returned"
        where: lookup_app_notification_type_bool_exp
    ): [lookup_app_notification_type!]!
    "fetch aggregated fields from the table: \"lookup.app_notification_type\""
    lookup_app_notification_type_aggregate(
        "distinct select on columns"
        distinct_on: [lookup_app_notification_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_app_notification_type_order_by!],
        "filter the rows returned"
        where: lookup_app_notification_type_bool_exp
    ): lookup_app_notification_type_aggregate!
    "fetch data from the table: \"lookup.app_notification_type\" using primary key columns"
    lookup_app_notification_type_by_pk(value: String!): lookup_app_notification_type
    "fetch data from the table: \"lookup.cms_content_block_type\""
    lookup_cms_content_block_type(
        "distinct select on columns"
        distinct_on: [lookup_cms_content_block_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_cms_content_block_type_order_by!],
        "filter the rows returned"
        where: lookup_cms_content_block_type_bool_exp
    ): [lookup_cms_content_block_type!]!
    "fetch aggregated fields from the table: \"lookup.cms_content_block_type\""
    lookup_cms_content_block_type_aggregate(
        "distinct select on columns"
        distinct_on: [lookup_cms_content_block_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_cms_content_block_type_order_by!],
        "filter the rows returned"
        where: lookup_cms_content_block_type_bool_exp
    ): lookup_cms_content_block_type_aggregate!
    "fetch data from the table: \"lookup.cms_content_block_type\" using primary key columns"
    lookup_cms_content_block_type_by_pk(value: String!): lookup_cms_content_block_type
    "fetch data from the table: \"lookup.cms_content_type\""
    lookup_cms_content_type(
        "distinct select on columns"
        distinct_on: [lookup_cms_content_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_cms_content_type_order_by!],
        "filter the rows returned"
        where: lookup_cms_content_type_bool_exp
    ): [lookup_cms_content_type!]!
    "fetch aggregated fields from the table: \"lookup.cms_content_type\""
    lookup_cms_content_type_aggregate(
        "distinct select on columns"
        distinct_on: [lookup_cms_content_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_cms_content_type_order_by!],
        "filter the rows returned"
        where: lookup_cms_content_type_bool_exp
    ): lookup_cms_content_type_aggregate!
    "fetch data from the table: \"lookup.cms_content_type\" using primary key columns"
    lookup_cms_content_type_by_pk(value: String!): lookup_cms_content_type
    "fetch data from the table: \"lookup.cp_visit_status\""
    lookup_cp_visit_status(
        "distinct select on columns"
        distinct_on: [lookup_cp_visit_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_cp_visit_status_order_by!],
        "filter the rows returned"
        where: lookup_cp_visit_status_bool_exp
    ): [lookup_cp_visit_status!]!
    "fetch aggregated fields from the table: \"lookup.cp_visit_status\""
    lookup_cp_visit_status_aggregate(
        "distinct select on columns"
        distinct_on: [lookup_cp_visit_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_cp_visit_status_order_by!],
        "filter the rows returned"
        where: lookup_cp_visit_status_bool_exp
    ): lookup_cp_visit_status_aggregate!
    "fetch data from the table: \"lookup.cp_visit_status\" using primary key columns"
    lookup_cp_visit_status_by_pk(value: String!): lookup_cp_visit_status
    "fetch data from the table: \"lookup.schema_audience_type\""
    lookup_schema_audience_type(
        "distinct select on columns"
        distinct_on: [lookup_schema_audience_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_schema_audience_type_order_by!],
        "filter the rows returned"
        where: lookup_schema_audience_type_bool_exp
    ): [lookup_schema_audience_type!]!
    "fetch aggregated fields from the table: \"lookup.schema_audience_type\""
    lookup_schema_audience_type_aggregate(
        "distinct select on columns"
        distinct_on: [lookup_schema_audience_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_schema_audience_type_order_by!],
        "filter the rows returned"
        where: lookup_schema_audience_type_bool_exp
    ): lookup_schema_audience_type_aggregate!
    "fetch data from the table: \"lookup.schema_audience_type\" using primary key columns"
    lookup_schema_audience_type_by_pk(value: String!): lookup_schema_audience_type
    "fetch data from the table: \"object.file\""
    object_file(
        "distinct select on columns"
        distinct_on: [object_file_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_file_order_by!],
        "filter the rows returned"
        where: object_file_bool_exp
    ): [object_file!]!
    "fetch aggregated fields from the table: \"object.file\""
    object_file_aggregate(
        "distinct select on columns"
        distinct_on: [object_file_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_file_order_by!],
        "filter the rows returned"
        where: object_file_bool_exp
    ): object_file_aggregate!
    "fetch data from the table: \"object.file\" using primary key columns"
    object_file_by_pk(id: String!): object_file
    "fetch data from the table: \"object.ie\""
    object_ie(
        "distinct select on columns"
        distinct_on: [object_ie_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_ie_order_by!],
        "filter the rows returned"
        where: object_ie_bool_exp
    ): [object_ie!]!
    "fetch aggregated fields from the table: \"object.ie\""
    object_ie_aggregate(
        "distinct select on columns"
        distinct_on: [object_ie_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_ie_order_by!],
        "filter the rows returned"
        where: object_ie_bool_exp
    ): object_ie_aggregate!
    "fetch data from the table: \"object.ie\" using primary key columns"
    object_ie_by_pk(
        "de unieke fragmentid in mediahaven"
        meemoo_fragment_id: String!
    ): object_ie
    "fetch data from the table: \"object.representation\""
    object_representation(
        "distinct select on columns"
        distinct_on: [object_representation_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_representation_order_by!],
        "filter the rows returned"
        where: object_representation_bool_exp
    ): [object_representation!]!
    "fetch aggregated fields from the table: \"object.representation\""
    object_representation_aggregate(
        "distinct select on columns"
        distinct_on: [object_representation_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_representation_order_by!],
        "filter the rows returned"
        where: object_representation_bool_exp
    ): object_representation_aggregate!
    "fetch data from the table: \"object.representation\" using primary key columns"
    object_representation_by_pk(id: String!): object_representation
    organizations(id: String, iri: String): [Organization]
    persons(family_name: String, given_name: String, iri: String): [Person]
    schools(id: String, iri: String): [School]
    "fetch data from the table: \"sync.audio\""
    sync_audio(
        "distinct select on columns"
        distinct_on: [sync_audio_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sync_audio_order_by!],
        "filter the rows returned"
        where: sync_audio_bool_exp
    ): [sync_audio!]!
    "fetch aggregated fields from the table: \"sync.audio\""
    sync_audio_aggregate(
        "distinct select on columns"
        distinct_on: [sync_audio_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sync_audio_order_by!],
        "filter the rows returned"
        where: sync_audio_bool_exp
    ): sync_audio_aggregate!
    "fetch data from the table: \"sync.audio\" using primary key columns"
    sync_audio_by_pk(
        "De meest unieke key: de mediafragment ID uit Mediahaven"
        meemoo_fragment_id: String!
    ): sync_audio
    "fetch data from the table: \"sync.film\""
    sync_film(
        "distinct select on columns"
        distinct_on: [sync_film_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sync_film_order_by!],
        "filter the rows returned"
        where: sync_film_bool_exp
    ): [sync_film!]!
    "fetch aggregated fields from the table: \"sync.film\""
    sync_film_aggregate(
        "distinct select on columns"
        distinct_on: [sync_film_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sync_film_order_by!],
        "filter the rows returned"
        where: sync_film_bool_exp
    ): sync_film_aggregate!
    "fetch data from the table: \"sync.film\" using primary key columns"
    sync_film_by_pk(
        "De meest unieke key: de mediafragment ID uit Mediahaven"
        meemoo_fragment_id: String!
    ): sync_film
    "fetch data from the table: \"sync.video\""
    sync_video(
        "distinct select on columns"
        distinct_on: [sync_video_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sync_video_order_by!],
        "filter the rows returned"
        where: sync_video_bool_exp
    ): [sync_video!]!
    "fetch aggregated fields from the table: \"sync.video\""
    sync_video_aggregate(
        "distinct select on columns"
        distinct_on: [sync_video_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sync_video_order_by!],
        "filter the rows returned"
        where: sync_video_bool_exp
    ): sync_video_aggregate!
    "fetch data from the table: \"sync.video\" using primary key columns"
    sync_video_by_pk(
        "De meest unieke key: de mediafragment ID uit Mediahaven"
        meemoo_fragment_id: String!
    ): sync_video
    "fetch data from the table: \"users.collection\""
    users_collection(
        "distinct select on columns"
        distinct_on: [users_collection_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_collection_order_by!],
        "filter the rows returned"
        where: users_collection_bool_exp
    ): [users_collection!]!
    "fetch aggregated fields from the table: \"users.collection\""
    users_collection_aggregate(
        "distinct select on columns"
        distinct_on: [users_collection_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_collection_order_by!],
        "filter the rows returned"
        where: users_collection_bool_exp
    ): users_collection_aggregate!
    "fetch data from the table: \"users.collection\" using primary key columns"
    users_collection_by_pk(id: uuid!): users_collection
    "fetch data from the table: \"users.collection_ie\""
    users_collection_ie(
        "distinct select on columns"
        distinct_on: [users_collection_ie_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_collection_ie_order_by!],
        "filter the rows returned"
        where: users_collection_ie_bool_exp
    ): [users_collection_ie!]!
    "fetch aggregated fields from the table: \"users.collection_ie\""
    users_collection_ie_aggregate(
        "distinct select on columns"
        distinct_on: [users_collection_ie_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_collection_ie_order_by!],
        "filter the rows returned"
        where: users_collection_ie_bool_exp
    ): users_collection_ie_aggregate!
    "fetch data from the table: \"users.collection_ie\" using primary key columns"
    users_collection_ie_by_pk(object_ie_meemoo_fragment_id: String!, user_collection_id: uuid!): users_collection_ie
    "fetch data from the table: \"users.group\""
    users_group(
        "distinct select on columns"
        distinct_on: [users_group_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_group_order_by!],
        "filter the rows returned"
        where: users_group_bool_exp
    ): [users_group!]!
    "fetch aggregated fields from the table: \"users.group\""
    users_group_aggregate(
        "distinct select on columns"
        distinct_on: [users_group_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_group_order_by!],
        "filter the rows returned"
        where: users_group_bool_exp
    ): users_group_aggregate!
    "fetch data from the table: \"users.group\" using primary key columns"
    users_group_by_pk(id: uuid!): users_group
    "fetch data from the table: \"users.group_permission\""
    users_group_permission(
        "distinct select on columns"
        distinct_on: [users_group_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_group_permission_order_by!],
        "filter the rows returned"
        where: users_group_permission_bool_exp
    ): [users_group_permission!]!
    "fetch aggregated fields from the table: \"users.group_permission\""
    users_group_permission_aggregate(
        "distinct select on columns"
        distinct_on: [users_group_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_group_permission_order_by!],
        "filter the rows returned"
        where: users_group_permission_bool_exp
    ): users_group_permission_aggregate!
    "fetch data from the table: \"users.group_permission\" using primary key columns"
    users_group_permission_by_pk(id: uuid!): users_group_permission
    "fetch data from the table: \"users.identity\""
    users_identity(
        "distinct select on columns"
        distinct_on: [users_identity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_identity_order_by!],
        "filter the rows returned"
        where: users_identity_bool_exp
    ): [users_identity!]!
    "fetch aggregated fields from the table: \"users.identity\""
    users_identity_aggregate(
        "distinct select on columns"
        distinct_on: [users_identity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_identity_order_by!],
        "filter the rows returned"
        where: users_identity_bool_exp
    ): users_identity_aggregate!
    "fetch data from the table: \"users.identity\" using primary key columns"
    users_identity_by_pk(id: uuid!): users_identity
    "fetch data from the table: \"users.identity_provider\""
    users_identity_provider(
        "distinct select on columns"
        distinct_on: [users_identity_provider_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_identity_provider_order_by!],
        "filter the rows returned"
        where: users_identity_provider_bool_exp
    ): [users_identity_provider!]!
    "fetch aggregated fields from the table: \"users.identity_provider\""
    users_identity_provider_aggregate(
        "distinct select on columns"
        distinct_on: [users_identity_provider_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_identity_provider_order_by!],
        "filter the rows returned"
        where: users_identity_provider_bool_exp
    ): users_identity_provider_aggregate!
    "fetch data from the table: \"users.identity_provider\" using primary key columns"
    users_identity_provider_by_pk(name: String!): users_identity_provider
    "fetch data from the table: \"users.permission\""
    users_permission(
        "distinct select on columns"
        distinct_on: [users_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_permission_order_by!],
        "filter the rows returned"
        where: users_permission_bool_exp
    ): [users_permission!]!
    "fetch aggregated fields from the table: \"users.permission\""
    users_permission_aggregate(
        "distinct select on columns"
        distinct_on: [users_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_permission_order_by!],
        "filter the rows returned"
        where: users_permission_bool_exp
    ): users_permission_aggregate!
    "fetch data from the table: \"users.permission\" using primary key columns"
    users_permission_by_pk(id: uuid!): users_permission
    "fetch data from the table: \"users.profile\""
    users_profile(
        "distinct select on columns"
        distinct_on: [users_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_profile_order_by!],
        "filter the rows returned"
        where: users_profile_bool_exp
    ): [users_profile!]!
    "fetch aggregated fields from the table: \"users.profile\""
    users_profile_aggregate(
        "distinct select on columns"
        distinct_on: [users_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_profile_order_by!],
        "filter the rows returned"
        where: users_profile_bool_exp
    ): users_profile_aggregate!
    "fetch data from the table: \"users.profile\" using primary key columns"
    users_profile_by_pk(id: uuid!): users_profile
}

type subscription_root {
    "fetch data from the table: \"app.notification\""
    app_notification(
        "distinct select on columns"
        distinct_on: [app_notification_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [app_notification_order_by!],
        "filter the rows returned"
        where: app_notification_bool_exp
    ): [app_notification!]!
    "fetch aggregated fields from the table: \"app.notification\""
    app_notification_aggregate(
        "distinct select on columns"
        distinct_on: [app_notification_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [app_notification_order_by!],
        "filter the rows returned"
        where: app_notification_bool_exp
    ): app_notification_aggregate!
    "fetch data from the table: \"app.notification\" using primary key columns"
    app_notification_by_pk(id: uuid!): app_notification
    "fetch data from the table: \"cms.content\""
    cms_content(
        "distinct select on columns"
        distinct_on: [cms_content_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_order_by!],
        "filter the rows returned"
        where: cms_content_bool_exp
    ): [cms_content!]!
    "fetch aggregated fields from the table: \"cms.content\""
    cms_content_aggregate(
        "distinct select on columns"
        distinct_on: [cms_content_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_order_by!],
        "filter the rows returned"
        where: cms_content_bool_exp
    ): cms_content_aggregate!
    "fetch data from the table: \"cms.content_blocks\""
    cms_content_blocks(
        "distinct select on columns"
        distinct_on: [cms_content_blocks_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_blocks_order_by!],
        "filter the rows returned"
        where: cms_content_blocks_bool_exp
    ): [cms_content_blocks!]!
    "fetch aggregated fields from the table: \"cms.content_blocks\""
    cms_content_blocks_aggregate(
        "distinct select on columns"
        distinct_on: [cms_content_blocks_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_blocks_order_by!],
        "filter the rows returned"
        where: cms_content_blocks_bool_exp
    ): cms_content_blocks_aggregate!
    "fetch data from the table: \"cms.content_blocks\" using primary key columns"
    cms_content_blocks_by_pk(id: uuid!): cms_content_blocks
    "fetch data from the table: \"cms.content\" using primary key columns"
    cms_content_by_pk(id: uuid!): cms_content
    "fetch data from the table: \"cms.content_content_labels\""
    cms_content_content_labels(
        "distinct select on columns"
        distinct_on: [cms_content_content_labels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_content_labels_order_by!],
        "filter the rows returned"
        where: cms_content_content_labels_bool_exp
    ): [cms_content_content_labels!]!
    "fetch aggregated fields from the table: \"cms.content_content_labels\""
    cms_content_content_labels_aggregate(
        "distinct select on columns"
        distinct_on: [cms_content_content_labels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_content_labels_order_by!],
        "filter the rows returned"
        where: cms_content_content_labels_bool_exp
    ): cms_content_content_labels_aggregate!
    "fetch data from the table: \"cms.content_content_labels\" using primary key columns"
    cms_content_content_labels_by_pk(id: uuid!): cms_content_content_labels
    "fetch data from the table: \"cms.content_labels\""
    cms_content_labels(
        "distinct select on columns"
        distinct_on: [cms_content_labels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_labels_order_by!],
        "filter the rows returned"
        where: cms_content_labels_bool_exp
    ): [cms_content_labels!]!
    "fetch aggregated fields from the table: \"cms.content_labels\""
    cms_content_labels_aggregate(
        "distinct select on columns"
        distinct_on: [cms_content_labels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_labels_order_by!],
        "filter the rows returned"
        where: cms_content_labels_bool_exp
    ): cms_content_labels_aggregate!
    "fetch data from the table: \"cms.content_labels\" using primary key columns"
    cms_content_labels_by_pk(id: uuid!): cms_content_labels
    "fetch data from the table: \"cms.navigation_element\""
    cms_navigation_element(
        "distinct select on columns"
        distinct_on: [cms_navigation_element_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_navigation_element_order_by!],
        "filter the rows returned"
        where: cms_navigation_element_bool_exp
    ): [cms_navigation_element!]!
    "fetch aggregated fields from the table: \"cms.navigation_element\""
    cms_navigation_element_aggregate(
        "distinct select on columns"
        distinct_on: [cms_navigation_element_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_navigation_element_order_by!],
        "filter the rows returned"
        where: cms_navigation_element_bool_exp
    ): cms_navigation_element_aggregate!
    "fetch data from the table: \"cms.navigation_element\" using primary key columns"
    cms_navigation_element_by_pk(id: uuid!): cms_navigation_element
    "fetch data from the table: \"cms.site_variables\""
    cms_site_variables(
        "distinct select on columns"
        distinct_on: [cms_site_variables_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_site_variables_order_by!],
        "filter the rows returned"
        where: cms_site_variables_bool_exp
    ): [cms_site_variables!]!
    "fetch aggregated fields from the table: \"cms.site_variables\""
    cms_site_variables_aggregate(
        "distinct select on columns"
        distinct_on: [cms_site_variables_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_site_variables_order_by!],
        "filter the rows returned"
        where: cms_site_variables_bool_exp
    ): cms_site_variables_aggregate!
    "fetch data from the table: \"cms.site_variables\" using primary key columns"
    cms_site_variables_by_pk(name: String!): cms_site_variables
    "fetch data from the table: \"cp.index\""
    cp_index(
        "distinct select on columns"
        distinct_on: [cp_index_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_index_order_by!],
        "filter the rows returned"
        where: cp_index_bool_exp
    ): [cp_index!]!
    "fetch aggregated fields from the table: \"cp.index\""
    cp_index_aggregate(
        "distinct select on columns"
        distinct_on: [cp_index_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_index_order_by!],
        "filter the rows returned"
        where: cp_index_bool_exp
    ): cp_index_aggregate!
    "fetch data from the table: \"cp.index\" using primary key columns"
    cp_index_by_pk(schema_maintainer_id: String!): cp_index
    "fetch data from the table: \"cp.maintainer\""
    cp_maintainer(
        "distinct select on columns"
        distinct_on: [cp_maintainer_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_maintainer_order_by!],
        "filter the rows returned"
        where: cp_maintainer_bool_exp
    ): [cp_maintainer!]!
    "fetch aggregated fields from the table: \"cp.maintainer\""
    cp_maintainer_aggregate(
        "distinct select on columns"
        distinct_on: [cp_maintainer_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_maintainer_order_by!],
        "filter the rows returned"
        where: cp_maintainer_bool_exp
    ): cp_maintainer_aggregate!
    "fetch data from the table: \"cp.maintainer\" using primary key columns"
    cp_maintainer_by_pk(schema_identifier: String!): cp_maintainer
    "fetch data from the table: \"cp.maintainer_users_profile\""
    cp_maintainer_users_profile(
        "distinct select on columns"
        distinct_on: [cp_maintainer_users_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_maintainer_users_profile_order_by!],
        "filter the rows returned"
        where: cp_maintainer_users_profile_bool_exp
    ): [cp_maintainer_users_profile!]!
    "fetch aggregated fields from the table: \"cp.maintainer_users_profile\""
    cp_maintainer_users_profile_aggregate(
        "distinct select on columns"
        distinct_on: [cp_maintainer_users_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_maintainer_users_profile_order_by!],
        "filter the rows returned"
        where: cp_maintainer_users_profile_bool_exp
    ): cp_maintainer_users_profile_aggregate!
    "fetch data from the table: \"cp.maintainer_users_profile\" using primary key columns"
    cp_maintainer_users_profile_by_pk(id: uuid!): cp_maintainer_users_profile
    "fetch data from the table: \"cp.space\""
    cp_space(
        "distinct select on columns"
        distinct_on: [cp_space_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_space_order_by!],
        "filter the rows returned"
        where: cp_space_bool_exp
    ): [cp_space!]!
    "fetch aggregated fields from the table: \"cp.space\""
    cp_space_aggregate(
        "distinct select on columns"
        distinct_on: [cp_space_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_space_order_by!],
        "filter the rows returned"
        where: cp_space_bool_exp
    ): cp_space_aggregate!
    "fetch data from the table: \"cp.space\" using primary key columns"
    cp_space_by_pk(id: uuid!): cp_space
    "fetch data from the table: \"cp.visit\""
    cp_visit(
        "distinct select on columns"
        distinct_on: [cp_visit_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_order_by!],
        "filter the rows returned"
        where: cp_visit_bool_exp
    ): [cp_visit!]!
    "fetch aggregated fields from the table: \"cp.visit\""
    cp_visit_aggregate(
        "distinct select on columns"
        distinct_on: [cp_visit_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_order_by!],
        "filter the rows returned"
        where: cp_visit_bool_exp
    ): cp_visit_aggregate!
    "fetch data from the table: \"cp.visit\" using primary key columns"
    cp_visit_by_pk(id: uuid!): cp_visit
    "fetch data from the table: \"cp.visit_note\""
    cp_visit_note(
        "distinct select on columns"
        distinct_on: [cp_visit_note_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_note_order_by!],
        "filter the rows returned"
        where: cp_visit_note_bool_exp
    ): [cp_visit_note!]!
    "fetch aggregated fields from the table: \"cp.visit_note\""
    cp_visit_note_aggregate(
        "distinct select on columns"
        distinct_on: [cp_visit_note_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_note_order_by!],
        "filter the rows returned"
        where: cp_visit_note_bool_exp
    ): cp_visit_note_aggregate!
    "fetch data from the table: \"cp.visit_note\" using primary key columns"
    cp_visit_note_by_pk(id: uuid!): cp_visit_note
    "fetch data from the table: \"lookup.app_notification_type\""
    lookup_app_notification_type(
        "distinct select on columns"
        distinct_on: [lookup_app_notification_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_app_notification_type_order_by!],
        "filter the rows returned"
        where: lookup_app_notification_type_bool_exp
    ): [lookup_app_notification_type!]!
    "fetch aggregated fields from the table: \"lookup.app_notification_type\""
    lookup_app_notification_type_aggregate(
        "distinct select on columns"
        distinct_on: [lookup_app_notification_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_app_notification_type_order_by!],
        "filter the rows returned"
        where: lookup_app_notification_type_bool_exp
    ): lookup_app_notification_type_aggregate!
    "fetch data from the table: \"lookup.app_notification_type\" using primary key columns"
    lookup_app_notification_type_by_pk(value: String!): lookup_app_notification_type
    "fetch data from the table: \"lookup.cms_content_block_type\""
    lookup_cms_content_block_type(
        "distinct select on columns"
        distinct_on: [lookup_cms_content_block_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_cms_content_block_type_order_by!],
        "filter the rows returned"
        where: lookup_cms_content_block_type_bool_exp
    ): [lookup_cms_content_block_type!]!
    "fetch aggregated fields from the table: \"lookup.cms_content_block_type\""
    lookup_cms_content_block_type_aggregate(
        "distinct select on columns"
        distinct_on: [lookup_cms_content_block_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_cms_content_block_type_order_by!],
        "filter the rows returned"
        where: lookup_cms_content_block_type_bool_exp
    ): lookup_cms_content_block_type_aggregate!
    "fetch data from the table: \"lookup.cms_content_block_type\" using primary key columns"
    lookup_cms_content_block_type_by_pk(value: String!): lookup_cms_content_block_type
    "fetch data from the table: \"lookup.cms_content_type\""
    lookup_cms_content_type(
        "distinct select on columns"
        distinct_on: [lookup_cms_content_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_cms_content_type_order_by!],
        "filter the rows returned"
        where: lookup_cms_content_type_bool_exp
    ): [lookup_cms_content_type!]!
    "fetch aggregated fields from the table: \"lookup.cms_content_type\""
    lookup_cms_content_type_aggregate(
        "distinct select on columns"
        distinct_on: [lookup_cms_content_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_cms_content_type_order_by!],
        "filter the rows returned"
        where: lookup_cms_content_type_bool_exp
    ): lookup_cms_content_type_aggregate!
    "fetch data from the table: \"lookup.cms_content_type\" using primary key columns"
    lookup_cms_content_type_by_pk(value: String!): lookup_cms_content_type
    "fetch data from the table: \"lookup.cp_visit_status\""
    lookup_cp_visit_status(
        "distinct select on columns"
        distinct_on: [lookup_cp_visit_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_cp_visit_status_order_by!],
        "filter the rows returned"
        where: lookup_cp_visit_status_bool_exp
    ): [lookup_cp_visit_status!]!
    "fetch aggregated fields from the table: \"lookup.cp_visit_status\""
    lookup_cp_visit_status_aggregate(
        "distinct select on columns"
        distinct_on: [lookup_cp_visit_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_cp_visit_status_order_by!],
        "filter the rows returned"
        where: lookup_cp_visit_status_bool_exp
    ): lookup_cp_visit_status_aggregate!
    "fetch data from the table: \"lookup.cp_visit_status\" using primary key columns"
    lookup_cp_visit_status_by_pk(value: String!): lookup_cp_visit_status
    "fetch data from the table: \"lookup.schema_audience_type\""
    lookup_schema_audience_type(
        "distinct select on columns"
        distinct_on: [lookup_schema_audience_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_schema_audience_type_order_by!],
        "filter the rows returned"
        where: lookup_schema_audience_type_bool_exp
    ): [lookup_schema_audience_type!]!
    "fetch aggregated fields from the table: \"lookup.schema_audience_type\""
    lookup_schema_audience_type_aggregate(
        "distinct select on columns"
        distinct_on: [lookup_schema_audience_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [lookup_schema_audience_type_order_by!],
        "filter the rows returned"
        where: lookup_schema_audience_type_bool_exp
    ): lookup_schema_audience_type_aggregate!
    "fetch data from the table: \"lookup.schema_audience_type\" using primary key columns"
    lookup_schema_audience_type_by_pk(value: String!): lookup_schema_audience_type
    "fetch data from the table: \"object.file\""
    object_file(
        "distinct select on columns"
        distinct_on: [object_file_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_file_order_by!],
        "filter the rows returned"
        where: object_file_bool_exp
    ): [object_file!]!
    "fetch aggregated fields from the table: \"object.file\""
    object_file_aggregate(
        "distinct select on columns"
        distinct_on: [object_file_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_file_order_by!],
        "filter the rows returned"
        where: object_file_bool_exp
    ): object_file_aggregate!
    "fetch data from the table: \"object.file\" using primary key columns"
    object_file_by_pk(id: String!): object_file
    "fetch data from the table: \"object.ie\""
    object_ie(
        "distinct select on columns"
        distinct_on: [object_ie_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_ie_order_by!],
        "filter the rows returned"
        where: object_ie_bool_exp
    ): [object_ie!]!
    "fetch aggregated fields from the table: \"object.ie\""
    object_ie_aggregate(
        "distinct select on columns"
        distinct_on: [object_ie_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_ie_order_by!],
        "filter the rows returned"
        where: object_ie_bool_exp
    ): object_ie_aggregate!
    "fetch data from the table: \"object.ie\" using primary key columns"
    object_ie_by_pk(
        "de unieke fragmentid in mediahaven"
        meemoo_fragment_id: String!
    ): object_ie
    "fetch data from the table: \"object.representation\""
    object_representation(
        "distinct select on columns"
        distinct_on: [object_representation_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_representation_order_by!],
        "filter the rows returned"
        where: object_representation_bool_exp
    ): [object_representation!]!
    "fetch aggregated fields from the table: \"object.representation\""
    object_representation_aggregate(
        "distinct select on columns"
        distinct_on: [object_representation_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_representation_order_by!],
        "filter the rows returned"
        where: object_representation_bool_exp
    ): object_representation_aggregate!
    "fetch data from the table: \"object.representation\" using primary key columns"
    object_representation_by_pk(id: String!): object_representation
    "fetch data from the table: \"sync.audio\""
    sync_audio(
        "distinct select on columns"
        distinct_on: [sync_audio_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sync_audio_order_by!],
        "filter the rows returned"
        where: sync_audio_bool_exp
    ): [sync_audio!]!
    "fetch aggregated fields from the table: \"sync.audio\""
    sync_audio_aggregate(
        "distinct select on columns"
        distinct_on: [sync_audio_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sync_audio_order_by!],
        "filter the rows returned"
        where: sync_audio_bool_exp
    ): sync_audio_aggregate!
    "fetch data from the table: \"sync.audio\" using primary key columns"
    sync_audio_by_pk(
        "De meest unieke key: de mediafragment ID uit Mediahaven"
        meemoo_fragment_id: String!
    ): sync_audio
    "fetch data from the table: \"sync.film\""
    sync_film(
        "distinct select on columns"
        distinct_on: [sync_film_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sync_film_order_by!],
        "filter the rows returned"
        where: sync_film_bool_exp
    ): [sync_film!]!
    "fetch aggregated fields from the table: \"sync.film\""
    sync_film_aggregate(
        "distinct select on columns"
        distinct_on: [sync_film_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sync_film_order_by!],
        "filter the rows returned"
        where: sync_film_bool_exp
    ): sync_film_aggregate!
    "fetch data from the table: \"sync.film\" using primary key columns"
    sync_film_by_pk(
        "De meest unieke key: de mediafragment ID uit Mediahaven"
        meemoo_fragment_id: String!
    ): sync_film
    "fetch data from the table: \"sync.video\""
    sync_video(
        "distinct select on columns"
        distinct_on: [sync_video_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sync_video_order_by!],
        "filter the rows returned"
        where: sync_video_bool_exp
    ): [sync_video!]!
    "fetch aggregated fields from the table: \"sync.video\""
    sync_video_aggregate(
        "distinct select on columns"
        distinct_on: [sync_video_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sync_video_order_by!],
        "filter the rows returned"
        where: sync_video_bool_exp
    ): sync_video_aggregate!
    "fetch data from the table: \"sync.video\" using primary key columns"
    sync_video_by_pk(
        "De meest unieke key: de mediafragment ID uit Mediahaven"
        meemoo_fragment_id: String!
    ): sync_video
    "fetch data from the table: \"users.collection\""
    users_collection(
        "distinct select on columns"
        distinct_on: [users_collection_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_collection_order_by!],
        "filter the rows returned"
        where: users_collection_bool_exp
    ): [users_collection!]!
    "fetch aggregated fields from the table: \"users.collection\""
    users_collection_aggregate(
        "distinct select on columns"
        distinct_on: [users_collection_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_collection_order_by!],
        "filter the rows returned"
        where: users_collection_bool_exp
    ): users_collection_aggregate!
    "fetch data from the table: \"users.collection\" using primary key columns"
    users_collection_by_pk(id: uuid!): users_collection
    "fetch data from the table: \"users.collection_ie\""
    users_collection_ie(
        "distinct select on columns"
        distinct_on: [users_collection_ie_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_collection_ie_order_by!],
        "filter the rows returned"
        where: users_collection_ie_bool_exp
    ): [users_collection_ie!]!
    "fetch aggregated fields from the table: \"users.collection_ie\""
    users_collection_ie_aggregate(
        "distinct select on columns"
        distinct_on: [users_collection_ie_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_collection_ie_order_by!],
        "filter the rows returned"
        where: users_collection_ie_bool_exp
    ): users_collection_ie_aggregate!
    "fetch data from the table: \"users.collection_ie\" using primary key columns"
    users_collection_ie_by_pk(object_ie_meemoo_fragment_id: String!, user_collection_id: uuid!): users_collection_ie
    "fetch data from the table: \"users.group\""
    users_group(
        "distinct select on columns"
        distinct_on: [users_group_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_group_order_by!],
        "filter the rows returned"
        where: users_group_bool_exp
    ): [users_group!]!
    "fetch aggregated fields from the table: \"users.group\""
    users_group_aggregate(
        "distinct select on columns"
        distinct_on: [users_group_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_group_order_by!],
        "filter the rows returned"
        where: users_group_bool_exp
    ): users_group_aggregate!
    "fetch data from the table: \"users.group\" using primary key columns"
    users_group_by_pk(id: uuid!): users_group
    "fetch data from the table: \"users.group_permission\""
    users_group_permission(
        "distinct select on columns"
        distinct_on: [users_group_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_group_permission_order_by!],
        "filter the rows returned"
        where: users_group_permission_bool_exp
    ): [users_group_permission!]!
    "fetch aggregated fields from the table: \"users.group_permission\""
    users_group_permission_aggregate(
        "distinct select on columns"
        distinct_on: [users_group_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_group_permission_order_by!],
        "filter the rows returned"
        where: users_group_permission_bool_exp
    ): users_group_permission_aggregate!
    "fetch data from the table: \"users.group_permission\" using primary key columns"
    users_group_permission_by_pk(id: uuid!): users_group_permission
    "fetch data from the table: \"users.identity\""
    users_identity(
        "distinct select on columns"
        distinct_on: [users_identity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_identity_order_by!],
        "filter the rows returned"
        where: users_identity_bool_exp
    ): [users_identity!]!
    "fetch aggregated fields from the table: \"users.identity\""
    users_identity_aggregate(
        "distinct select on columns"
        distinct_on: [users_identity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_identity_order_by!],
        "filter the rows returned"
        where: users_identity_bool_exp
    ): users_identity_aggregate!
    "fetch data from the table: \"users.identity\" using primary key columns"
    users_identity_by_pk(id: uuid!): users_identity
    "fetch data from the table: \"users.identity_provider\""
    users_identity_provider(
        "distinct select on columns"
        distinct_on: [users_identity_provider_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_identity_provider_order_by!],
        "filter the rows returned"
        where: users_identity_provider_bool_exp
    ): [users_identity_provider!]!
    "fetch aggregated fields from the table: \"users.identity_provider\""
    users_identity_provider_aggregate(
        "distinct select on columns"
        distinct_on: [users_identity_provider_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_identity_provider_order_by!],
        "filter the rows returned"
        where: users_identity_provider_bool_exp
    ): users_identity_provider_aggregate!
    "fetch data from the table: \"users.identity_provider\" using primary key columns"
    users_identity_provider_by_pk(name: String!): users_identity_provider
    "fetch data from the table: \"users.permission\""
    users_permission(
        "distinct select on columns"
        distinct_on: [users_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_permission_order_by!],
        "filter the rows returned"
        where: users_permission_bool_exp
    ): [users_permission!]!
    "fetch aggregated fields from the table: \"users.permission\""
    users_permission_aggregate(
        "distinct select on columns"
        distinct_on: [users_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_permission_order_by!],
        "filter the rows returned"
        where: users_permission_bool_exp
    ): users_permission_aggregate!
    "fetch data from the table: \"users.permission\" using primary key columns"
    users_permission_by_pk(id: uuid!): users_permission
    "fetch data from the table: \"users.profile\""
    users_profile(
        "distinct select on columns"
        distinct_on: [users_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_profile_order_by!],
        "filter the rows returned"
        where: users_profile_bool_exp
    ): [users_profile!]!
    "fetch aggregated fields from the table: \"users.profile\""
    users_profile_aggregate(
        "distinct select on columns"
        distinct_on: [users_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_profile_order_by!],
        "filter the rows returned"
        where: users_profile_bool_exp
    ): users_profile_aggregate!
    "fetch data from the table: \"users.profile\" using primary key columns"
    users_profile_by_pk(id: uuid!): users_profile
}

"columns and relationships of \"sync.audio\""
type sync_audio {
    created_at: timestamptz!
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data(
        "JSON select path"
        path: String
    ): jsonb!
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String!
    "De meemoo pid of external_id"
    schema_identifier: String!
    "De OR-ID van de aanbiedende CP"
    schema_maintainer_id: String!
    "De human readable titel van het object"
    schema_name: String!
    status: String!
    updated_at: timestamptz!
}

"aggregated selection of \"sync.audio\""
type sync_audio_aggregate {
    aggregate: sync_audio_aggregate_fields
    nodes: [sync_audio!]!
}

"aggregate fields of \"sync.audio\""
type sync_audio_aggregate_fields {
    count(columns: [sync_audio_select_column!], distinct: Boolean): Int!
    max: sync_audio_max_fields
    min: sync_audio_min_fields
}

"aggregate max on columns"
type sync_audio_max_fields {
    created_at: timestamptz
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String
    "De meemoo pid of external_id"
    schema_identifier: String
    "De OR-ID van de aanbiedende CP"
    schema_maintainer_id: String
    "De human readable titel van het object"
    schema_name: String
    status: String
    updated_at: timestamptz
}

"aggregate min on columns"
type sync_audio_min_fields {
    created_at: timestamptz
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String
    "De meemoo pid of external_id"
    schema_identifier: String
    "De OR-ID van de aanbiedende CP"
    schema_maintainer_id: String
    "De human readable titel van het object"
    schema_name: String
    status: String
    updated_at: timestamptz
}

"response of any mutation on the table \"sync.audio\""
type sync_audio_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [sync_audio!]!
}

"columns and relationships of \"sync.film\""
type sync_film {
    created_at: timestamptz!
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data(
        "JSON select path"
        path: String
    ): jsonb!
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String!
    "De meemoo pid of external_id"
    schema_identifier: String!
    "De OR-ID van de aanbiedende CP"
    schema_maintainer_id: String!
    "De human readable titel van het object"
    schema_name: String!
    status: String!
    updated_at: timestamptz!
}

"aggregated selection of \"sync.film\""
type sync_film_aggregate {
    aggregate: sync_film_aggregate_fields
    nodes: [sync_film!]!
}

"aggregate fields of \"sync.film\""
type sync_film_aggregate_fields {
    count(columns: [sync_film_select_column!], distinct: Boolean): Int!
    max: sync_film_max_fields
    min: sync_film_min_fields
}

"aggregate max on columns"
type sync_film_max_fields {
    created_at: timestamptz
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String
    "De meemoo pid of external_id"
    schema_identifier: String
    "De OR-ID van de aanbiedende CP"
    schema_maintainer_id: String
    "De human readable titel van het object"
    schema_name: String
    status: String
    updated_at: timestamptz
}

"aggregate min on columns"
type sync_film_min_fields {
    created_at: timestamptz
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String
    "De meemoo pid of external_id"
    schema_identifier: String
    "De OR-ID van de aanbiedende CP"
    schema_maintainer_id: String
    "De human readable titel van het object"
    schema_name: String
    status: String
    updated_at: timestamptz
}

"response of any mutation on the table \"sync.film\""
type sync_film_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [sync_film!]!
}

"""

Sync table for video objects


columns and relationships of "sync.video"
"""
type sync_video {
    created_at: timestamptz!
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data(
        "JSON select path"
        path: String
    ): jsonb!
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String!
    "De meemoo pid of external_id"
    schema_identifier: String!
    "De OR-ID van de aanbiedende CP"
    schema_maintainer_id: String!
    "De human readable titel van het object"
    schema_name: String!
    status: String!
    updated_at: timestamptz!
}

"aggregated selection of \"sync.video\""
type sync_video_aggregate {
    aggregate: sync_video_aggregate_fields
    nodes: [sync_video!]!
}

"aggregate fields of \"sync.video\""
type sync_video_aggregate_fields {
    count(columns: [sync_video_select_column!], distinct: Boolean): Int!
    max: sync_video_max_fields
    min: sync_video_min_fields
}

"aggregate max on columns"
type sync_video_max_fields {
    created_at: timestamptz
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String
    "De meemoo pid of external_id"
    schema_identifier: String
    "De OR-ID van de aanbiedende CP"
    schema_maintainer_id: String
    "De human readable titel van het object"
    schema_name: String
    status: String
    updated_at: timestamptz
}

"aggregate min on columns"
type sync_video_min_fields {
    created_at: timestamptz
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String
    "De meemoo pid of external_id"
    schema_identifier: String
    "De OR-ID van de aanbiedende CP"
    schema_maintainer_id: String
    "De human readable titel van het object"
    schema_name: String
    status: String
    updated_at: timestamptz
}

"response of any mutation on the table \"sync.video\""
type sync_video_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [sync_video!]!
}

"""

Verzamelingen van items aangemaakt door gebruikers zoals favorieten


columns and relationships of "users.collection"
"""
type users_collection {
    created_at: timestamp!
    id: uuid!
    "An array relationship"
    ies(
        "distinct select on columns"
        distinct_on: [users_collection_ie_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_collection_ie_order_by!],
        "filter the rows returned"
        where: users_collection_ie_bool_exp
    ): [users_collection_ie!]!
    "An aggregate relationship"
    ies_aggregate(
        "distinct select on columns"
        distinct_on: [users_collection_ie_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_collection_ie_order_by!],
        "filter the rows returned"
        where: users_collection_ie_bool_exp
    ): users_collection_ie_aggregate!
    is_default: Boolean
    name: String
    updated_at: timestamp
    "An object relationship"
    user_profile: users_profile!
    user_profile_id: uuid!
}

"aggregated selection of \"users.collection\""
type users_collection_aggregate {
    aggregate: users_collection_aggregate_fields
    nodes: [users_collection!]!
}

"aggregate fields of \"users.collection\""
type users_collection_aggregate_fields {
    count(columns: [users_collection_select_column!], distinct: Boolean): Int!
    max: users_collection_max_fields
    min: users_collection_min_fields
}

"""

Koppeltabel tussen user collections en object ie


columns and relationships of "users.collection_ie"
"""
type users_collection_ie {
    "An object relationship"
    collection: users_collection!
    created_at: timestamp!
    "An object relationship"
    ie: object_ie!
    object_ie_meemoo_fragment_id: String!
    updated_at: timestamp!
    user_collection_id: uuid!
}

"aggregated selection of \"users.collection_ie\""
type users_collection_ie_aggregate {
    aggregate: users_collection_ie_aggregate_fields
    nodes: [users_collection_ie!]!
}

"aggregate fields of \"users.collection_ie\""
type users_collection_ie_aggregate_fields {
    count(columns: [users_collection_ie_select_column!], distinct: Boolean): Int!
    max: users_collection_ie_max_fields
    min: users_collection_ie_min_fields
}

"aggregate max on columns"
type users_collection_ie_max_fields {
    created_at: timestamp
    object_ie_meemoo_fragment_id: String
    updated_at: timestamp
    user_collection_id: uuid
}

"aggregate min on columns"
type users_collection_ie_min_fields {
    created_at: timestamp
    object_ie_meemoo_fragment_id: String
    updated_at: timestamp
    user_collection_id: uuid
}

"response of any mutation on the table \"users.collection_ie\""
type users_collection_ie_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [users_collection_ie!]!
}

"aggregate max on columns"
type users_collection_max_fields {
    created_at: timestamp
    id: uuid
    name: String
    updated_at: timestamp
    user_profile_id: uuid
}

"aggregate min on columns"
type users_collection_min_fields {
    created_at: timestamp
    id: uuid
    name: String
    updated_at: timestamp
    user_profile_id: uuid
}

"response of any mutation on the table \"users.collection\""
type users_collection_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [users_collection!]!
}

"""

Gebruikersgroepen


columns and relationships of "users.group"
"""
type users_group {
    created_at: timestamp!
    description: String
    id: uuid!
    label: String!
    name: String!
    "An array relationship"
    permissions(
        "distinct select on columns"
        distinct_on: [users_group_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_group_permission_order_by!],
        "filter the rows returned"
        where: users_group_permission_bool_exp
    ): [users_group_permission!]!
    "An aggregate relationship"
    permissions_aggregate(
        "distinct select on columns"
        distinct_on: [users_group_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_group_permission_order_by!],
        "filter the rows returned"
        where: users_group_permission_bool_exp
    ): users_group_permission_aggregate!
    "An array relationship"
    profiles(
        "distinct select on columns"
        distinct_on: [users_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_profile_order_by!],
        "filter the rows returned"
        where: users_profile_bool_exp
    ): [users_profile!]!
    "An aggregate relationship"
    profiles_aggregate(
        "distinct select on columns"
        distinct_on: [users_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_profile_order_by!],
        "filter the rows returned"
        where: users_profile_bool_exp
    ): users_profile_aggregate!
    updated_at: timestamp!
}

"aggregated selection of \"users.group\""
type users_group_aggregate {
    aggregate: users_group_aggregate_fields
    nodes: [users_group!]!
}

"aggregate fields of \"users.group\""
type users_group_aggregate_fields {
    count(columns: [users_group_select_column!], distinct: Boolean): Int!
    max: users_group_max_fields
    min: users_group_min_fields
}

"aggregate max on columns"
type users_group_max_fields {
    created_at: timestamp
    description: String
    id: uuid
    label: String
    name: String
    updated_at: timestamp
}

"aggregate min on columns"
type users_group_min_fields {
    created_at: timestamp
    description: String
    id: uuid
    label: String
    name: String
    updated_at: timestamp
}

"response of any mutation on the table \"users.group\""
type users_group_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [users_group!]!
}

"""

Koppeltabel voor het koppelen van permissies aan gebruikersgroepen


columns and relationships of "users.group_permission"
"""
type users_group_permission {
    "An object relationship"
    group: users_group!
    group_id: uuid!
    id: uuid!
    "An object relationship"
    permission: users_permission!
    permission_id: uuid!
}

"aggregated selection of \"users.group_permission\""
type users_group_permission_aggregate {
    aggregate: users_group_permission_aggregate_fields
    nodes: [users_group_permission!]!
}

"aggregate fields of \"users.group_permission\""
type users_group_permission_aggregate_fields {
    count(columns: [users_group_permission_select_column!], distinct: Boolean): Int!
    max: users_group_permission_max_fields
    min: users_group_permission_min_fields
}

"aggregate max on columns"
type users_group_permission_max_fields {
    group_id: uuid
    id: uuid
    permission_id: uuid
}

"aggregate min on columns"
type users_group_permission_min_fields {
    group_id: uuid
    id: uuid
    permission_id: uuid
}

"response of any mutation on the table \"users.group_permission\""
type users_group_permission_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [users_group_permission!]!
}

"""

List of user idps and id


columns and relationships of "users.identity"
"""
type users_identity {
    created_at: timestamptz!
    id: uuid!
    identity_id: String!
    "An object relationship"
    identity_provider: users_identity_provider!
    identity_provider_name: String!
    "An object relationship"
    profile: users_profile!
    profile_id: uuid!
    updated_at: timestamptz!
}

"aggregated selection of \"users.identity\""
type users_identity_aggregate {
    aggregate: users_identity_aggregate_fields
    nodes: [users_identity!]!
}

"aggregate fields of \"users.identity\""
type users_identity_aggregate_fields {
    count(columns: [users_identity_select_column!], distinct: Boolean): Int!
    max: users_identity_max_fields
    min: users_identity_min_fields
}

"aggregate max on columns"
type users_identity_max_fields {
    created_at: timestamptz
    id: uuid
    identity_id: String
    identity_provider_name: String
    profile_id: uuid
    updated_at: timestamptz
}

"aggregate min on columns"
type users_identity_min_fields {
    created_at: timestamptz
    id: uuid
    identity_id: String
    identity_provider_name: String
    profile_id: uuid
    updated_at: timestamptz
}

"response of any mutation on the table \"users.identity\""
type users_identity_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [users_identity!]!
}

"columns and relationships of \"users.identity_provider\""
type users_identity_provider {
    description: String
    "An array relationship"
    identities(
        "distinct select on columns"
        distinct_on: [users_identity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_identity_order_by!],
        "filter the rows returned"
        where: users_identity_bool_exp
    ): [users_identity!]!
    "An aggregate relationship"
    identities_aggregate(
        "distinct select on columns"
        distinct_on: [users_identity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_identity_order_by!],
        "filter the rows returned"
        where: users_identity_bool_exp
    ): users_identity_aggregate!
    name: String!
}

"aggregated selection of \"users.identity_provider\""
type users_identity_provider_aggregate {
    aggregate: users_identity_provider_aggregate_fields
    nodes: [users_identity_provider!]!
}

"aggregate fields of \"users.identity_provider\""
type users_identity_provider_aggregate_fields {
    count(columns: [users_identity_provider_select_column!], distinct: Boolean): Int!
    max: users_identity_provider_max_fields
    min: users_identity_provider_min_fields
}

"aggregate max on columns"
type users_identity_provider_max_fields {
    description: String
    name: String
}

"aggregate min on columns"
type users_identity_provider_min_fields {
    description: String
    name: String
}

"response of any mutation on the table \"users.identity_provider\""
type users_identity_provider_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [users_identity_provider!]!
}

"""

Wat een gebruiker mag doen


columns and relationships of "users.permission"
"""
type users_permission {
    created_at: timestamp!
    description: String
    "An array relationship"
    groups(
        "distinct select on columns"
        distinct_on: [users_group_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_group_permission_order_by!],
        "filter the rows returned"
        where: users_group_permission_bool_exp
    ): [users_group_permission!]!
    "An aggregate relationship"
    groups_aggregate(
        "distinct select on columns"
        distinct_on: [users_group_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_group_permission_order_by!],
        "filter the rows returned"
        where: users_group_permission_bool_exp
    ): users_group_permission_aggregate!
    id: uuid!
    label: String!
    name: String!
    updated_at: timestamp!
}

"aggregated selection of \"users.permission\""
type users_permission_aggregate {
    aggregate: users_permission_aggregate_fields
    nodes: [users_permission!]!
}

"aggregate fields of \"users.permission\""
type users_permission_aggregate_fields {
    count(columns: [users_permission_select_column!], distinct: Boolean): Int!
    max: users_permission_max_fields
    min: users_permission_min_fields
}

"aggregate max on columns"
type users_permission_max_fields {
    created_at: timestamp
    description: String
    id: uuid
    label: String
    name: String
    updated_at: timestamp
}

"aggregate min on columns"
type users_permission_min_fields {
    created_at: timestamp
    description: String
    id: uuid
    label: String
    name: String
    updated_at: timestamp
}

"response of any mutation on the table \"users.permission\""
type users_permission_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [users_permission!]!
}

"""

A user his identifying attributes aka profile information


columns and relationships of "users.profile"
"""
type users_profile {
    accepted_tos_at: timestamptz
    "An array relationship"
    collections(
        "distinct select on columns"
        distinct_on: [users_collection_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_collection_order_by!],
        "filter the rows returned"
        where: users_collection_bool_exp
    ): [users_collection!]!
    "An aggregate relationship"
    collections_aggregate(
        "distinct select on columns"
        distinct_on: [users_collection_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_collection_order_by!],
        "filter the rows returned"
        where: users_collection_bool_exp
    ): users_collection_aggregate!
    "An array relationship"
    contents(
        "distinct select on columns"
        distinct_on: [cms_content_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_order_by!],
        "filter the rows returned"
        where: cms_content_bool_exp
    ): [cms_content!]!
    "An array relationship"
    contentsByUserProfileId(
        "distinct select on columns"
        distinct_on: [cms_content_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_order_by!],
        "filter the rows returned"
        where: cms_content_bool_exp
    ): [cms_content!]!
    "An aggregate relationship"
    contentsByUserProfileId_aggregate(
        "distinct select on columns"
        distinct_on: [cms_content_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_order_by!],
        "filter the rows returned"
        where: cms_content_bool_exp
    ): cms_content_aggregate!
    "An aggregate relationship"
    contents_aggregate(
        "distinct select on columns"
        distinct_on: [cms_content_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cms_content_order_by!],
        "filter the rows returned"
        where: cms_content_bool_exp
    ): cms_content_aggregate!
    created_at: timestamp
    first_name: String
    "A computed field, executes function \"users.user_profile_full_name\""
    full_name: String
    "An object relationship"
    group: users_group
    group_id: uuid
    id: uuid!
    "An array relationship"
    identities(
        "distinct select on columns"
        distinct_on: [users_identity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_identity_order_by!],
        "filter the rows returned"
        where: users_identity_bool_exp
    ): [users_identity!]!
    "An aggregate relationship"
    identities_aggregate(
        "distinct select on columns"
        distinct_on: [users_identity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_identity_order_by!],
        "filter the rows returned"
        where: users_identity_bool_exp
    ): users_identity_aggregate!
    last_name: String
    mail: String
    "An array relationship"
    maintainer_users_profiles(
        "distinct select on columns"
        distinct_on: [cp_maintainer_users_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_maintainer_users_profile_order_by!],
        "filter the rows returned"
        where: cp_maintainer_users_profile_bool_exp
    ): [cp_maintainer_users_profile!]!
    "An aggregate relationship"
    maintainer_users_profiles_aggregate(
        "distinct select on columns"
        distinct_on: [cp_maintainer_users_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_maintainer_users_profile_order_by!],
        "filter the rows returned"
        where: cp_maintainer_users_profile_bool_exp
    ): cp_maintainer_users_profile_aggregate!
    "An array relationship"
    notes(
        "distinct select on columns"
        distinct_on: [cp_visit_note_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_note_order_by!],
        "filter the rows returned"
        where: cp_visit_note_bool_exp
    ): [cp_visit_note!]!
    "An aggregate relationship"
    notes_aggregate(
        "distinct select on columns"
        distinct_on: [cp_visit_note_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_note_order_by!],
        "filter the rows returned"
        where: cp_visit_note_bool_exp
    ): cp_visit_note_aggregate!
    "An array relationship"
    notifications(
        "distinct select on columns"
        distinct_on: [app_notification_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [app_notification_order_by!],
        "filter the rows returned"
        where: app_notification_bool_exp
    ): [app_notification!]!
    "An aggregate relationship"
    notifications_aggregate(
        "distinct select on columns"
        distinct_on: [app_notification_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [app_notification_order_by!],
        "filter the rows returned"
        where: app_notification_bool_exp
    ): app_notification_aggregate!
    updated_at: timestamp
    "An array relationship"
    visits(
        "distinct select on columns"
        distinct_on: [cp_visit_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_order_by!],
        "filter the rows returned"
        where: cp_visit_bool_exp
    ): [cp_visit!]!
    "An array relationship"
    visitsByUpdatedBy(
        "distinct select on columns"
        distinct_on: [cp_visit_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_order_by!],
        "filter the rows returned"
        where: cp_visit_bool_exp
    ): [cp_visit!]!
    "An aggregate relationship"
    visitsByUpdatedBy_aggregate(
        "distinct select on columns"
        distinct_on: [cp_visit_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_order_by!],
        "filter the rows returned"
        where: cp_visit_bool_exp
    ): cp_visit_aggregate!
    "An aggregate relationship"
    visits_aggregate(
        "distinct select on columns"
        distinct_on: [cp_visit_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [cp_visit_order_by!],
        "filter the rows returned"
        where: cp_visit_bool_exp
    ): cp_visit_aggregate!
}

"aggregated selection of \"users.profile\""
type users_profile_aggregate {
    aggregate: users_profile_aggregate_fields
    nodes: [users_profile!]!
}

"aggregate fields of \"users.profile\""
type users_profile_aggregate_fields {
    count(columns: [users_profile_select_column!], distinct: Boolean): Int!
    max: users_profile_max_fields
    min: users_profile_min_fields
}

"aggregate max on columns"
type users_profile_max_fields {
    accepted_tos_at: timestamptz
    created_at: timestamp
    first_name: String
    group_id: uuid
    id: uuid
    last_name: String
    mail: String
    updated_at: timestamp
}

"aggregate min on columns"
type users_profile_min_fields {
    accepted_tos_at: timestamptz
    created_at: timestamp
    first_name: String
    group_id: uuid
    id: uuid
    last_name: String
    mail: String
    updated_at: timestamp
}

"response of any mutation on the table \"users.profile\""
type users_profile_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [users_profile!]!
}

"unique or primary key constraints on table \"app.notification\""
enum app_notification_constraint {
    "unique or primary key constraint"
    notification_pkey
}

"select columns of table \"app.notification\""
enum app_notification_select_column {
    "column name"
    created_at
    "column name"
    description
    "column name"
    id
    "column name"
    recipient
    "column name"
    status
    "column name"
    title
    "column name"
    type
    "column name"
    updated_at
    "column name"
    visit_id
}

"update columns of table \"app.notification\""
enum app_notification_update_column {
    "column name"
    created_at
    "column name"
    description
    "column name"
    id
    "column name"
    recipient
    "column name"
    status
    "column name"
    title
    "column name"
    type
    "column name"
    updated_at
    "column name"
    visit_id
}

"unique or primary key constraints on table \"cms.content_blocks\""
enum cms_content_blocks_constraint {
    "unique or primary key constraint"
    content_blocks_pkey
}

"select columns of table \"cms.content_blocks\""
enum cms_content_blocks_select_column {
    "column name"
    content_block_type
    "column name"
    content_id
    "column name"
    created_at
    "column name"
    id
    "column name"
    position
    "column name"
    updated_at
    "column name"
    variables
}

"update columns of table \"cms.content_blocks\""
enum cms_content_blocks_update_column {
    "column name"
    content_block_type
    "column name"
    content_id
    "column name"
    created_at
    "column name"
    id
    "column name"
    position
    "column name"
    updated_at
    "column name"
    variables
}

"unique or primary key constraints on table \"cms.content\""
enum cms_content_constraint {
    "unique or primary key constraint"
    content_id_key
    "unique or primary key constraint"
    content_path_key
    "unique or primary key constraint"
    content_pkey
}

"unique or primary key constraints on table \"cms.content_content_labels\""
enum cms_content_content_labels_constraint {
    "unique or primary key constraint"
    content_content_labels_pkey
}

"select columns of table \"cms.content_content_labels\""
enum cms_content_content_labels_select_column {
    "column name"
    content_id
    "column name"
    created_at
    "column name"
    id
    "column name"
    label_id
    "column name"
    updated_at
}

"update columns of table \"cms.content_content_labels\""
enum cms_content_content_labels_update_column {
    "column name"
    content_id
    "column name"
    created_at
    "column name"
    id
    "column name"
    label_id
    "column name"
    updated_at
}

"unique or primary key constraints on table \"cms.content_labels\""
enum cms_content_labels_constraint {
    "unique or primary key constraint"
    content_labels_label_content_type_key
    "unique or primary key constraint"
    content_labels_pkey
}

"select columns of table \"cms.content_labels\""
enum cms_content_labels_select_column {
    "column name"
    content_type
    "column name"
    created_at
    "column name"
    id
    "column name"
    label
    "column name"
    link_to
    "column name"
    updated_at
}

"update columns of table \"cms.content_labels\""
enum cms_content_labels_update_column {
    "column name"
    content_type
    "column name"
    created_at
    "column name"
    id
    "column name"
    label
    "column name"
    link_to
    "column name"
    updated_at
}

"select columns of table \"cms.content\""
enum cms_content_select_column {
    "column name"
    content_type
    "column name"
    content_width
    "column name"
    created_at
    "column name"
    depublish_at
    "column name"
    description
    "column name"
    header_path
    "column name"
    id
    "column name"
    is_deleted
    "column name"
    is_protected
    "column name"
    is_public
    "column name"
    meta_description
    "column name"
    path
    "column name"
    publish_at
    "column name"
    published_at
    "column name"
    seo_description
    "column name"
    seo_image_path
    "column name"
    seo_keywords
    "column name"
    seo_title
    "column name"
    thumbnail_path
    "column name"
    title
    "column name"
    updated_at
    "column name"
    updated_by_profile_id
    "column name"
    user_group_ids
    "column name"
    user_profile_id
}

"update columns of table \"cms.content\""
enum cms_content_update_column {
    "column name"
    content_type
    "column name"
    content_width
    "column name"
    created_at
    "column name"
    depublish_at
    "column name"
    description
    "column name"
    header_path
    "column name"
    id
    "column name"
    is_deleted
    "column name"
    is_protected
    "column name"
    is_public
    "column name"
    meta_description
    "column name"
    path
    "column name"
    publish_at
    "column name"
    published_at
    "column name"
    seo_description
    "column name"
    seo_image_path
    "column name"
    seo_keywords
    "column name"
    seo_title
    "column name"
    thumbnail_path
    "column name"
    title
    "column name"
    updated_at
    "column name"
    updated_by_profile_id
    "column name"
    user_group_ids
    "column name"
    user_profile_id
}

"unique or primary key constraints on table \"cms.navigation_element\""
enum cms_navigation_element_constraint {
    "unique or primary key constraint"
    navigation_element_pkey
}

"select columns of table \"cms.navigation_element\""
enum cms_navigation_element_select_column {
    "column name"
    content_id
    "column name"
    content_path
    "column name"
    content_type
    "column name"
    created_at
    "column name"
    description
    "column name"
    icon_name
    "column name"
    id
    "column name"
    label
    "column name"
    link_target
    "column name"
    placement
    "column name"
    position
    "column name"
    tooltip
    "column name"
    updated_at
    "column name"
    user_group_ids
}

"update columns of table \"cms.navigation_element\""
enum cms_navigation_element_update_column {
    "column name"
    content_id
    "column name"
    content_path
    "column name"
    content_type
    "column name"
    created_at
    "column name"
    description
    "column name"
    icon_name
    "column name"
    id
    "column name"
    label
    "column name"
    link_target
    "column name"
    placement
    "column name"
    position
    "column name"
    tooltip
    "column name"
    updated_at
    "column name"
    user_group_ids
}

"unique or primary key constraints on table \"cms.site_variables\""
enum cms_site_variables_constraint {
    "unique or primary key constraint"
    site_variables_pkey
}

"select columns of table \"cms.site_variables\""
enum cms_site_variables_select_column {
    "column name"
    created_at
    "column name"
    name
    "column name"
    updated_at
    "column name"
    value
}

"update columns of table \"cms.site_variables\""
enum cms_site_variables_update_column {
    "column name"
    created_at
    "column name"
    name
    "column name"
    updated_at
    "column name"
    value
}

"unique or primary key constraints on table \"cp.index\""
enum cp_index_constraint {
    "unique or primary key constraint"
    index_pkey
}

"select columns of table \"cp.index\""
enum cp_index_select_column {
    "column name"
    created_at
    "column name"
    schema_maintainer_id
    "column name"
    schema_name
    "column name"
    updated_at
}

"update columns of table \"cp.index\""
enum cp_index_update_column {
    "column name"
    created_at
    "column name"
    schema_maintainer_id
    "column name"
    schema_name
    "column name"
    updated_at
}

"unique or primary key constraints on table \"cp.maintainer\""
enum cp_maintainer_constraint {
    "unique or primary key constraint"
    maintainer_pkey
}

"select columns of table \"cp.maintainer\""
enum cp_maintainer_select_column {
    "column name"
    created_at
    "column name"
    has_index
    "column name"
    has_space
    "column name"
    schema_identifier
    "column name"
    schema_name
    "column name"
    updated_at
}

"update columns of table \"cp.maintainer\""
enum cp_maintainer_update_column {
    "column name"
    created_at
    "column name"
    has_index
    "column name"
    has_space
    "column name"
    schema_identifier
    "column name"
    schema_name
    "column name"
    updated_at
}

"unique or primary key constraints on table \"cp.maintainer_users_profile\""
enum cp_maintainer_users_profile_constraint {
    "unique or primary key constraint"
    maintainer_users_profile_maintainer_identifier_users_profil_key
    "unique or primary key constraint"
    maintainer_users_profile_pkey
}

"select columns of table \"cp.maintainer_users_profile\""
enum cp_maintainer_users_profile_select_column {
    "column name"
    id
    "column name"
    maintainer_identifier
    "column name"
    users_profile_id
}

"update columns of table \"cp.maintainer_users_profile\""
enum cp_maintainer_users_profile_update_column {
    "column name"
    id
    "column name"
    maintainer_identifier
    "column name"
    users_profile_id
}

"unique or primary key constraints on table \"cp.space\""
enum cp_space_constraint {
    "unique or primary key constraint"
    space_pkey
    "unique or primary key constraint"
    space_schema_maintainer_id_key
}

"select columns of table \"cp.space\""
enum cp_space_select_column {
    "column name"
    created_at
    "column name"
    id
    "column name"
    is_published
    "column name"
    published_at
    "column name"
    schema_audience_type
    "column name"
    schema_color
    "column name"
    schema_description
    "column name"
    schema_image
    "column name"
    schema_maintainer_id
    "column name"
    schema_public_access
    "column name"
    schema_service_description
    "column name"
    updated_at
}

"update columns of table \"cp.space\""
enum cp_space_update_column {
    "column name"
    created_at
    "column name"
    id
    "column name"
    is_published
    "column name"
    published_at
    "column name"
    schema_audience_type
    "column name"
    schema_color
    "column name"
    schema_description
    "column name"
    schema_image
    "column name"
    schema_maintainer_id
    "column name"
    schema_public_access
    "column name"
    schema_service_description
    "column name"
    updated_at
}

"unique or primary key constraints on table \"cp.visit\""
enum cp_visit_constraint {
    "unique or primary key constraint"
    visit_pkey
}

"unique or primary key constraints on table \"cp.visit_note\""
enum cp_visit_note_constraint {
    "unique or primary key constraint"
    visit_note_pkey
}

"select columns of table \"cp.visit_note\""
enum cp_visit_note_select_column {
    "column name"
    created_at
    "column name"
    id
    "column name"
    note
    "column name"
    profile_id
    "column name"
    updated_at
    "column name"
    visit_id
}

"update columns of table \"cp.visit_note\""
enum cp_visit_note_update_column {
    "column name"
    created_at
    "column name"
    id
    "column name"
    note
    "column name"
    profile_id
    "column name"
    updated_at
    "column name"
    visit_id
}

"select columns of table \"cp.visit\""
enum cp_visit_select_column {
    "column name"
    cp_space_id
    "column name"
    created_at
    "column name"
    end_date
    "column name"
    id
    "column name"
    start_date
    "column name"
    status
    "column name"
    updated_at
    "column name"
    updated_by
    "column name"
    user_accepted_tos
    "column name"
    user_profile_id
    "column name"
    user_reason
    "column name"
    user_timeframe
}

"update columns of table \"cp.visit\""
enum cp_visit_update_column {
    "column name"
    cp_space_id
    "column name"
    created_at
    "column name"
    end_date
    "column name"
    id
    "column name"
    start_date
    "column name"
    status
    "column name"
    updated_at
    "column name"
    updated_by
    "column name"
    user_accepted_tos
    "column name"
    user_profile_id
    "column name"
    user_reason
    "column name"
    user_timeframe
}

"unique or primary key constraints on table \"lookup.app_notification_type\""
enum lookup_app_notification_type_constraint {
    "unique or primary key constraint"
    app_notification_type_pkey
}

"select columns of table \"lookup.app_notification_type\""
enum lookup_app_notification_type_select_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"lookup.app_notification_type\""
enum lookup_app_notification_type_update_column {
    "column name"
    comment
    "column name"
    value
}

"unique or primary key constraints on table \"lookup.cms_content_block_type\""
enum lookup_cms_content_block_type_constraint {
    "unique or primary key constraint"
    cms_content_block_type_pkey
}

"select columns of table \"lookup.cms_content_block_type\""
enum lookup_cms_content_block_type_select_column {
    "column name"
    description
    "column name"
    value
}

"update columns of table \"lookup.cms_content_block_type\""
enum lookup_cms_content_block_type_update_column {
    "column name"
    description
    "column name"
    value
}

"unique or primary key constraints on table \"lookup.cms_content_type\""
enum lookup_cms_content_type_constraint {
    "unique or primary key constraint"
    cms_content_type_pkey
}

"select columns of table \"lookup.cms_content_type\""
enum lookup_cms_content_type_select_column {
    "column name"
    description
    "column name"
    value
}

"update columns of table \"lookup.cms_content_type\""
enum lookup_cms_content_type_update_column {
    "column name"
    description
    "column name"
    value
}

"unique or primary key constraints on table \"lookup.cp_visit_status\""
enum lookup_cp_visit_status_constraint {
    "unique or primary key constraint"
    cp_visit_status_pkey
}

"select columns of table \"lookup.cp_visit_status\""
enum lookup_cp_visit_status_select_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"lookup.cp_visit_status\""
enum lookup_cp_visit_status_update_column {
    "column name"
    comment
    "column name"
    value
}

"unique or primary key constraints on table \"lookup.schema_audience_type\""
enum lookup_schema_audience_type_constraint {
    "unique or primary key constraint"
    schema_audience_type_pkey
}

enum lookup_schema_audience_type_enum {
    "The resource is restricted to private access or use."
    PRIVATE
    "The resource is intended for public access or use."
    PUBLIC
}

"select columns of table \"lookup.schema_audience_type\""
enum lookup_schema_audience_type_select_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"lookup.schema_audience_type\""
enum lookup_schema_audience_type_update_column {
    "column name"
    comment
    "column name"
    value
}

"unique or primary key constraints on table \"object.file\""
enum object_file_constraint {
    "unique or primary key constraint"
    file_pkey
}

"select columns of table \"object.file\""
enum object_file_select_column {
    "column name"
    ebucore_is_media_fragment_of
    "column name"
    ebucore_media_type
    "column name"
    id
    "column name"
    representation_id
    "column name"
    schema_alternate_name
    "column name"
    schema_description
    "column name"
    schema_embed_url
    "column name"
    schema_name
}

"update columns of table \"object.file\""
enum object_file_update_column {
    "column name"
    ebucore_is_media_fragment_of
    "column name"
    ebucore_media_type
    "column name"
    id
    "column name"
    representation_id
    "column name"
    schema_alternate_name
    "column name"
    schema_description
    "column name"
    schema_embed_url
    "column name"
    schema_name
}

"unique or primary key constraints on table \"object.ie\""
enum object_ie_constraint {
    "unique or primary key constraint"
    ie_meemoo_fragment_id_key
    "unique or primary key constraint"
    intellectual_entity_pkey
}

"select columns of table \"object.ie\""
enum object_ie_select_column {
    "column name"
    dcterms_available
    "column name"
    dcterms_created
    "column name"
    dcterms_format
    "column name"
    dcterms_issued
    "column name"
    dcterms_medium
    "column name"
    ebucore_object_type
    "column name"
    meemoo_fragment_id
    "column name"
    meemoo_media_object_id
    "column name"
    meemoofilm_base
    "column name"
    meemoofilm_color
    "column name"
    meemoofilm_contains_embedded_caption
    "column name"
    meemoofilm_embeddedCaptionLanguage
    "column name"
    meemoofilm_image_or_sound
    "column name"
    premis_identifier
    "column name"
    premis_is_part_of
    "column name"
    premis_relationship
    "column name"
    schema_abstract
    "column name"
    schema_actor
    "column name"
    schema_alternate_name
    "column name"
    schema_contributor
    "column name"
    schema_copyright_holder
    "column name"
    schema_copyright_notice
    "column name"
    schema_creator
    "column name"
    schema_date_created
    "column name"
    schema_date_created_lower_bound
    "column name"
    schema_date_published
    "column name"
    schema_description
    "column name"
    schema_duration
    "column name"
    schema_duration_in_seconds
    "column name"
    schema_genre
    "column name"
    schema_identifier
    "column name"
    schema_in_language
    "column name"
    schema_is_part_of
    "column name"
    schema_keywords
    "column name"
    schema_license
    "column name"
    schema_maintainer_id
    "column name"
    schema_maintainer_id_lower
    "column name"
    schema_name
    "column name"
    schema_number_of_pages
    "column name"
    schema_part_of_archive
    "column name"
    schema_part_of_episode
    "column name"
    schema_part_of_season
    "column name"
    schema_part_of_series
    "column name"
    schema_publisher
    "column name"
    schema_spatial_coverage
    "column name"
    schema_temporal_coverage
    "column name"
    schema_thumbnail_url
    "column name"
    updated_at
}

"update columns of table \"object.ie\""
enum object_ie_update_column {
    "column name"
    dcterms_available
    "column name"
    dcterms_created
    "column name"
    dcterms_format
    "column name"
    dcterms_issued
    "column name"
    dcterms_medium
    "column name"
    ebucore_object_type
    "column name"
    meemoo_fragment_id
    "column name"
    meemoo_media_object_id
    "column name"
    meemoofilm_base
    "column name"
    meemoofilm_color
    "column name"
    meemoofilm_contains_embedded_caption
    "column name"
    meemoofilm_embeddedCaptionLanguage
    "column name"
    meemoofilm_image_or_sound
    "column name"
    premis_identifier
    "column name"
    premis_is_part_of
    "column name"
    premis_relationship
    "column name"
    schema_abstract
    "column name"
    schema_actor
    "column name"
    schema_alternate_name
    "column name"
    schema_contributor
    "column name"
    schema_copyright_holder
    "column name"
    schema_copyright_notice
    "column name"
    schema_creator
    "column name"
    schema_date_created
    "column name"
    schema_date_created_lower_bound
    "column name"
    schema_date_published
    "column name"
    schema_description
    "column name"
    schema_duration
    "column name"
    schema_duration_in_seconds
    "column name"
    schema_genre
    "column name"
    schema_identifier
    "column name"
    schema_in_language
    "column name"
    schema_is_part_of
    "column name"
    schema_keywords
    "column name"
    schema_license
    "column name"
    schema_maintainer_id
    "column name"
    schema_maintainer_id_lower
    "column name"
    schema_name
    "column name"
    schema_number_of_pages
    "column name"
    schema_part_of_archive
    "column name"
    schema_part_of_episode
    "column name"
    schema_part_of_season
    "column name"
    schema_part_of_series
    "column name"
    schema_publisher
    "column name"
    schema_spatial_coverage
    "column name"
    schema_temporal_coverage
    "column name"
    schema_thumbnail_url
    "column name"
    updated_at
}

"unique or primary key constraints on table \"object.representation\""
enum object_representation_constraint {
    "unique or primary key constraint"
    representation_id_key
    "unique or primary key constraint"
    representation_pkey
}

"select columns of table \"object.representation\""
enum object_representation_select_column {
    "column name"
    dcterms_format
    "column name"
    id
    "column name"
    ie_meemoo_fragment_id
    "column name"
    schema_alternate_name
    "column name"
    schema_date_created
    "column name"
    schema_description
    "column name"
    schema_name
    "column name"
    schema_transcript
}

"update columns of table \"object.representation\""
enum object_representation_update_column {
    "column name"
    dcterms_format
    "column name"
    id
    "column name"
    ie_meemoo_fragment_id
    "column name"
    schema_alternate_name
    "column name"
    schema_date_created
    "column name"
    schema_description
    "column name"
    schema_name
    "column name"
    schema_transcript
}

"column ordering options"
enum order_by {
    "in ascending order, nulls last"
    asc
    "in ascending order, nulls first"
    asc_nulls_first
    "in ascending order, nulls last"
    asc_nulls_last
    "in descending order, nulls first"
    desc
    "in descending order, nulls first"
    desc_nulls_first
    "in descending order, nulls last"
    desc_nulls_last
}

"unique or primary key constraints on table \"sync.audio\""
enum sync_audio_constraint {
    "unique or primary key constraint"
    audio_pkey
}

"select columns of table \"sync.audio\""
enum sync_audio_select_column {
    "column name"
    created_at
    "column name"
    data
    "column name"
    meemoo_fragment_id
    "column name"
    schema_identifier
    "column name"
    schema_maintainer_id
    "column name"
    schema_name
    "column name"
    status
    "column name"
    updated_at
}

"update columns of table \"sync.audio\""
enum sync_audio_update_column {
    "column name"
    created_at
    "column name"
    data
    "column name"
    meemoo_fragment_id
    "column name"
    schema_identifier
    "column name"
    schema_maintainer_id
    "column name"
    schema_name
    "column name"
    status
    "column name"
    updated_at
}

"unique or primary key constraints on table \"sync.film\""
enum sync_film_constraint {
    "unique or primary key constraint"
    film_complex_pkey
}

"select columns of table \"sync.film\""
enum sync_film_select_column {
    "column name"
    created_at
    "column name"
    data
    "column name"
    meemoo_fragment_id
    "column name"
    schema_identifier
    "column name"
    schema_maintainer_id
    "column name"
    schema_name
    "column name"
    status
    "column name"
    updated_at
}

"update columns of table \"sync.film\""
enum sync_film_update_column {
    "column name"
    created_at
    "column name"
    data
    "column name"
    meemoo_fragment_id
    "column name"
    schema_identifier
    "column name"
    schema_maintainer_id
    "column name"
    schema_name
    "column name"
    status
    "column name"
    updated_at
}

"unique or primary key constraints on table \"sync.video\""
enum sync_video_constraint {
    "unique or primary key constraint"
    video_pkey
}

"select columns of table \"sync.video\""
enum sync_video_select_column {
    "column name"
    created_at
    "column name"
    data
    "column name"
    meemoo_fragment_id
    "column name"
    schema_identifier
    "column name"
    schema_maintainer_id
    "column name"
    schema_name
    "column name"
    status
    "column name"
    updated_at
}

"update columns of table \"sync.video\""
enum sync_video_update_column {
    "column name"
    created_at
    "column name"
    data
    "column name"
    meemoo_fragment_id
    "column name"
    schema_identifier
    "column name"
    schema_maintainer_id
    "column name"
    schema_name
    "column name"
    status
    "column name"
    updated_at
}

"unique or primary key constraints on table \"users.collection\""
enum users_collection_constraint {
    "unique or primary key constraint"
    collection_pkey
}

"unique or primary key constraints on table \"users.collection_ie\""
enum users_collection_ie_constraint {
    "unique or primary key constraint"
    collection_item_pkey
}

"select columns of table \"users.collection_ie\""
enum users_collection_ie_select_column {
    "column name"
    created_at
    "column name"
    object_ie_meemoo_fragment_id
    "column name"
    updated_at
    "column name"
    user_collection_id
}

"update columns of table \"users.collection_ie\""
enum users_collection_ie_update_column {
    "column name"
    created_at
    "column name"
    object_ie_meemoo_fragment_id
    "column name"
    updated_at
    "column name"
    user_collection_id
}

"select columns of table \"users.collection\""
enum users_collection_select_column {
    "column name"
    created_at
    "column name"
    id
    "column name"
    is_default
    "column name"
    name
    "column name"
    updated_at
    "column name"
    user_profile_id
}

"update columns of table \"users.collection\""
enum users_collection_update_column {
    "column name"
    created_at
    "column name"
    id
    "column name"
    is_default
    "column name"
    name
    "column name"
    updated_at
    "column name"
    user_profile_id
}

"unique or primary key constraints on table \"users.group\""
enum users_group_constraint {
    "unique or primary key constraint"
    group_pkey
}

"unique or primary key constraints on table \"users.group_permission\""
enum users_group_permission_constraint {
    "unique or primary key constraint"
    group_permission_group_id_permission_id_key
    "unique or primary key constraint"
    group_permission_pkey
}

"select columns of table \"users.group_permission\""
enum users_group_permission_select_column {
    "column name"
    group_id
    "column name"
    id
    "column name"
    permission_id
}

"update columns of table \"users.group_permission\""
enum users_group_permission_update_column {
    "column name"
    group_id
    "column name"
    id
    "column name"
    permission_id
}

"select columns of table \"users.group\""
enum users_group_select_column {
    "column name"
    created_at
    "column name"
    description
    "column name"
    id
    "column name"
    label
    "column name"
    name
    "column name"
    updated_at
}

"update columns of table \"users.group\""
enum users_group_update_column {
    "column name"
    created_at
    "column name"
    description
    "column name"
    id
    "column name"
    label
    "column name"
    name
    "column name"
    updated_at
}

"unique or primary key constraints on table \"users.identity\""
enum users_identity_constraint {
    "unique or primary key constraint"
    identities_pkey
    "unique or primary key constraint"
    identities_profile_id_identity_provider_id_key
}

"unique or primary key constraints on table \"users.identity_provider\""
enum users_identity_provider_constraint {
    "unique or primary key constraint"
    identity_providers_name_key
    "unique or primary key constraint"
    identity_providers_pkey
}

"select columns of table \"users.identity_provider\""
enum users_identity_provider_select_column {
    "column name"
    description
    "column name"
    name
}

"update columns of table \"users.identity_provider\""
enum users_identity_provider_update_column {
    "column name"
    description
    "column name"
    name
}

"select columns of table \"users.identity\""
enum users_identity_select_column {
    "column name"
    created_at
    "column name"
    id
    "column name"
    identity_id
    "column name"
    identity_provider_name
    "column name"
    profile_id
    "column name"
    updated_at
}

"update columns of table \"users.identity\""
enum users_identity_update_column {
    "column name"
    created_at
    "column name"
    id
    "column name"
    identity_id
    "column name"
    identity_provider_name
    "column name"
    profile_id
    "column name"
    updated_at
}

"unique or primary key constraints on table \"users.permission\""
enum users_permission_constraint {
    "unique or primary key constraint"
    permission_pkey
}

"select columns of table \"users.permission\""
enum users_permission_select_column {
    "column name"
    created_at
    "column name"
    description
    "column name"
    id
    "column name"
    label
    "column name"
    name
    "column name"
    updated_at
}

"update columns of table \"users.permission\""
enum users_permission_update_column {
    "column name"
    created_at
    "column name"
    description
    "column name"
    id
    "column name"
    label
    "column name"
    name
    "column name"
    updated_at
}

"unique or primary key constraints on table \"users.profile\""
enum users_profile_constraint {
    "unique or primary key constraint"
    profiles_pkey
}

"select columns of table \"users.profile\""
enum users_profile_select_column {
    "column name"
    accepted_tos_at
    "column name"
    created_at
    "column name"
    first_name
    "column name"
    group_id
    "column name"
    id
    "column name"
    last_name
    "column name"
    mail
    "column name"
    updated_at
}

"update columns of table \"users.profile\""
enum users_profile_update_column {
    "column name"
    accepted_tos_at
    "column name"
    created_at
    "column name"
    first_name
    "column name"
    group_id
    "column name"
    id
    "column name"
    last_name
    "column name"
    mail
    "column name"
    updated_at
}

scalar _text

scalar date

scalar daterange

scalar jsonb

scalar time

scalar timestamp

scalar timestamptz

scalar uuid

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
    _eq: Boolean
    _gt: Boolean
    _gte: Boolean
    _in: [Boolean!]
    _is_null: Boolean
    _lt: Boolean
    _lte: Boolean
    _neq: Boolean
    _nin: [Boolean!]
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
    _eq: String
    _gt: String
    _gte: String
    "does the column match the given case-insensitive pattern"
    _ilike: String
    _in: [String!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: String
    _is_null: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    "does the column NOT match the given case-insensitive pattern"
    _nilike: String
    _nin: [String!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: String
    "does the column NOT match the given pattern"
    _nlike: String
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: String
    "does the column NOT match the given SQL regular expression"
    _nsimilar: String
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: String
    "does the column match the given SQL regular expression"
    _similar: String
}

"Boolean expression to compare columns of type \"_text\". All fields are combined with logical 'AND'."
input _text_comparison_exp {
    _eq: _text
    _gt: _text
    _gte: _text
    _in: [_text!]
    _is_null: Boolean
    _lt: _text
    _lte: _text
    _neq: _text
    _nin: [_text!]
}

"order by aggregate values of table \"app.notification\""
input app_notification_aggregate_order_by {
    count: order_by
    max: app_notification_max_order_by
    min: app_notification_min_order_by
}

"input type for inserting array relation for remote table \"app.notification\""
input app_notification_arr_rel_insert_input {
    data: [app_notification_insert_input!]!
    "on conflict condition"
    on_conflict: app_notification_on_conflict
}

"Boolean expression to filter rows from the table \"app.notification\". All fields are combined with a logical 'AND'."
input app_notification_bool_exp {
    _and: [app_notification_bool_exp!]
    _not: app_notification_bool_exp
    _or: [app_notification_bool_exp!]
    created_at: timestamptz_comparison_exp
    description: String_comparison_exp
    id: uuid_comparison_exp
    profile: users_profile_bool_exp
    recipient: uuid_comparison_exp
    status: String_comparison_exp
    title: String_comparison_exp
    type: String_comparison_exp
    updated_at: timestamp_comparison_exp
    visit: cp_visit_bool_exp
    visit_id: uuid_comparison_exp
}

"input type for inserting data into table \"app.notification\""
input app_notification_insert_input {
    created_at: timestamptz
    description: String
    id: uuid
    profile: users_profile_obj_rel_insert_input
    "Profile id van de bedoelde ontvanger"
    recipient: uuid
    status: String
    title: String
    type: String
    updated_at: timestamp
    visit: cp_visit_obj_rel_insert_input
    "Indien de melding een bezoek(aanvraag) betreft"
    visit_id: uuid
}

"order by max() on columns of table \"app.notification\""
input app_notification_max_order_by {
    created_at: order_by
    description: order_by
    id: order_by
    "Profile id van de bedoelde ontvanger"
    recipient: order_by
    status: order_by
    title: order_by
    type: order_by
    updated_at: order_by
    "Indien de melding een bezoek(aanvraag) betreft"
    visit_id: order_by
}

"order by min() on columns of table \"app.notification\""
input app_notification_min_order_by {
    created_at: order_by
    description: order_by
    id: order_by
    "Profile id van de bedoelde ontvanger"
    recipient: order_by
    status: order_by
    title: order_by
    type: order_by
    updated_at: order_by
    "Indien de melding een bezoek(aanvraag) betreft"
    visit_id: order_by
}

"on conflict condition type for table \"app.notification\""
input app_notification_on_conflict {
    constraint: app_notification_constraint!
    update_columns: [app_notification_update_column!]! = []
    where: app_notification_bool_exp
}

"Ordering options when selecting data from \"app.notification\"."
input app_notification_order_by {
    created_at: order_by
    description: order_by
    id: order_by
    profile: users_profile_order_by
    recipient: order_by
    status: order_by
    title: order_by
    type: order_by
    updated_at: order_by
    visit: cp_visit_order_by
    visit_id: order_by
}

"primary key columns input for table: app_notification"
input app_notification_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"app.notification\""
input app_notification_set_input {
    created_at: timestamptz
    description: String
    id: uuid
    "Profile id van de bedoelde ontvanger"
    recipient: uuid
    status: String
    title: String
    type: String
    updated_at: timestamp
    "Indien de melding een bezoek(aanvraag) betreft"
    visit_id: uuid
}

"order by aggregate values of table \"cms.content\""
input cms_content_aggregate_order_by {
    count: order_by
    max: cms_content_max_order_by
    min: cms_content_min_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input cms_content_append_input {
    user_group_ids: jsonb
}

"input type for inserting array relation for remote table \"cms.content\""
input cms_content_arr_rel_insert_input {
    data: [cms_content_insert_input!]!
    "on conflict condition"
    on_conflict: cms_content_on_conflict
}

"order by aggregate values of table \"cms.content_blocks\""
input cms_content_blocks_aggregate_order_by {
    avg: cms_content_blocks_avg_order_by
    count: order_by
    max: cms_content_blocks_max_order_by
    min: cms_content_blocks_min_order_by
    stddev: cms_content_blocks_stddev_order_by
    stddev_pop: cms_content_blocks_stddev_pop_order_by
    stddev_samp: cms_content_blocks_stddev_samp_order_by
    sum: cms_content_blocks_sum_order_by
    var_pop: cms_content_blocks_var_pop_order_by
    var_samp: cms_content_blocks_var_samp_order_by
    variance: cms_content_blocks_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input cms_content_blocks_append_input {
    variables: jsonb
}

"input type for inserting array relation for remote table \"cms.content_blocks\""
input cms_content_blocks_arr_rel_insert_input {
    data: [cms_content_blocks_insert_input!]!
    "on conflict condition"
    on_conflict: cms_content_blocks_on_conflict
}

"order by avg() on columns of table \"cms.content_blocks\""
input cms_content_blocks_avg_order_by {
    position: order_by
}

"Boolean expression to filter rows from the table \"cms.content_blocks\". All fields are combined with a logical 'AND'."
input cms_content_blocks_bool_exp {
    _and: [cms_content_blocks_bool_exp!]
    _not: cms_content_blocks_bool_exp
    _or: [cms_content_blocks_bool_exp!]
    content: cms_content_bool_exp
    content_block_type: String_comparison_exp
    content_id: uuid_comparison_exp
    created_at: timestamp_comparison_exp
    id: uuid_comparison_exp
    position: Int_comparison_exp
    updated_at: timestamp_comparison_exp
    variables: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input cms_content_blocks_delete_at_path_input {
    variables: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input cms_content_blocks_delete_elem_input {
    variables: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input cms_content_blocks_delete_key_input {
    variables: String
}

"input type for incrementing numeric columns in table \"cms.content_blocks\""
input cms_content_blocks_inc_input {
    position: Int
}

"input type for inserting data into table \"cms.content_blocks\""
input cms_content_blocks_insert_input {
    content: cms_content_obj_rel_insert_input
    content_block_type: String
    content_id: uuid
    created_at: timestamp
    id: uuid
    position: Int
    updated_at: timestamp
    variables: jsonb
}

"order by max() on columns of table \"cms.content_blocks\""
input cms_content_blocks_max_order_by {
    content_block_type: order_by
    content_id: order_by
    created_at: order_by
    id: order_by
    position: order_by
    updated_at: order_by
}

"order by min() on columns of table \"cms.content_blocks\""
input cms_content_blocks_min_order_by {
    content_block_type: order_by
    content_id: order_by
    created_at: order_by
    id: order_by
    position: order_by
    updated_at: order_by
}

"on conflict condition type for table \"cms.content_blocks\""
input cms_content_blocks_on_conflict {
    constraint: cms_content_blocks_constraint!
    update_columns: [cms_content_blocks_update_column!]! = []
    where: cms_content_blocks_bool_exp
}

"Ordering options when selecting data from \"cms.content_blocks\"."
input cms_content_blocks_order_by {
    content: cms_content_order_by
    content_block_type: order_by
    content_id: order_by
    created_at: order_by
    id: order_by
    position: order_by
    updated_at: order_by
    variables: order_by
}

"primary key columns input for table: cms_content_blocks"
input cms_content_blocks_pk_columns_input {
    id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input cms_content_blocks_prepend_input {
    variables: jsonb
}

"input type for updating data in table \"cms.content_blocks\""
input cms_content_blocks_set_input {
    content_block_type: String
    content_id: uuid
    created_at: timestamp
    id: uuid
    position: Int
    updated_at: timestamp
    variables: jsonb
}

"order by stddev() on columns of table \"cms.content_blocks\""
input cms_content_blocks_stddev_order_by {
    position: order_by
}

"order by stddev_pop() on columns of table \"cms.content_blocks\""
input cms_content_blocks_stddev_pop_order_by {
    position: order_by
}

"order by stddev_samp() on columns of table \"cms.content_blocks\""
input cms_content_blocks_stddev_samp_order_by {
    position: order_by
}

"order by sum() on columns of table \"cms.content_blocks\""
input cms_content_blocks_sum_order_by {
    position: order_by
}

"order by var_pop() on columns of table \"cms.content_blocks\""
input cms_content_blocks_var_pop_order_by {
    position: order_by
}

"order by var_samp() on columns of table \"cms.content_blocks\""
input cms_content_blocks_var_samp_order_by {
    position: order_by
}

"order by variance() on columns of table \"cms.content_blocks\""
input cms_content_blocks_variance_order_by {
    position: order_by
}

"Boolean expression to filter rows from the table \"cms.content\". All fields are combined with a logical 'AND'."
input cms_content_bool_exp {
    _and: [cms_content_bool_exp!]
    _not: cms_content_bool_exp
    _or: [cms_content_bool_exp!]
    content_blocks: cms_content_blocks_bool_exp
    content_content_labels: cms_content_content_labels_bool_exp
    content_type: String_comparison_exp
    content_width: String_comparison_exp
    created_at: timestamp_comparison_exp
    depublish_at: timestamp_comparison_exp
    description: String_comparison_exp
    header_path: String_comparison_exp
    id: uuid_comparison_exp
    is_deleted: Boolean_comparison_exp
    is_protected: Boolean_comparison_exp
    is_public: Boolean_comparison_exp
    meta_description: String_comparison_exp
    owner_profile: users_profile_bool_exp
    path: String_comparison_exp
    publish_at: timestamp_comparison_exp
    published_at: timestamp_comparison_exp
    seo_description: String_comparison_exp
    seo_image_path: String_comparison_exp
    seo_keywords: String_comparison_exp
    seo_title: String_comparison_exp
    thumbnail_path: String_comparison_exp
    title: String_comparison_exp
    updated_at: timestamp_comparison_exp
    updated_by_profile_id: uuid_comparison_exp
    updater_profile: users_profile_bool_exp
    user_group_ids: jsonb_comparison_exp
    user_profile_id: uuid_comparison_exp
}

"order by aggregate values of table \"cms.content_content_labels\""
input cms_content_content_labels_aggregate_order_by {
    count: order_by
    max: cms_content_content_labels_max_order_by
    min: cms_content_content_labels_min_order_by
}

"input type for inserting array relation for remote table \"cms.content_content_labels\""
input cms_content_content_labels_arr_rel_insert_input {
    data: [cms_content_content_labels_insert_input!]!
    "on conflict condition"
    on_conflict: cms_content_content_labels_on_conflict
}

"Boolean expression to filter rows from the table \"cms.content_content_labels\". All fields are combined with a logical 'AND'."
input cms_content_content_labels_bool_exp {
    _and: [cms_content_content_labels_bool_exp!]
    _not: cms_content_content_labels_bool_exp
    _or: [cms_content_content_labels_bool_exp!]
    content: cms_content_bool_exp
    content_id: uuid_comparison_exp
    content_label: cms_content_labels_bool_exp
    created_at: timestamp_comparison_exp
    id: uuid_comparison_exp
    label_id: uuid_comparison_exp
    updated_at: timestamp_comparison_exp
}

"input type for inserting data into table \"cms.content_content_labels\""
input cms_content_content_labels_insert_input {
    content: cms_content_obj_rel_insert_input
    content_id: uuid
    content_label: cms_content_labels_obj_rel_insert_input
    created_at: timestamp
    id: uuid
    label_id: uuid
    updated_at: timestamp
}

"order by max() on columns of table \"cms.content_content_labels\""
input cms_content_content_labels_max_order_by {
    content_id: order_by
    created_at: order_by
    id: order_by
    label_id: order_by
    updated_at: order_by
}

"order by min() on columns of table \"cms.content_content_labels\""
input cms_content_content_labels_min_order_by {
    content_id: order_by
    created_at: order_by
    id: order_by
    label_id: order_by
    updated_at: order_by
}

"on conflict condition type for table \"cms.content_content_labels\""
input cms_content_content_labels_on_conflict {
    constraint: cms_content_content_labels_constraint!
    update_columns: [cms_content_content_labels_update_column!]! = []
    where: cms_content_content_labels_bool_exp
}

"Ordering options when selecting data from \"cms.content_content_labels\"."
input cms_content_content_labels_order_by {
    content: cms_content_order_by
    content_id: order_by
    content_label: cms_content_labels_order_by
    created_at: order_by
    id: order_by
    label_id: order_by
    updated_at: order_by
}

"primary key columns input for table: cms_content_content_labels"
input cms_content_content_labels_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"cms.content_content_labels\""
input cms_content_content_labels_set_input {
    content_id: uuid
    created_at: timestamp
    id: uuid
    label_id: uuid
    updated_at: timestamp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input cms_content_delete_at_path_input {
    user_group_ids: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input cms_content_delete_elem_input {
    user_group_ids: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input cms_content_delete_key_input {
    user_group_ids: String
}

"input type for inserting data into table \"cms.content\""
input cms_content_insert_input {
    content_blocks: cms_content_blocks_arr_rel_insert_input
    content_content_labels: cms_content_content_labels_arr_rel_insert_input
    content_type: String
    content_width: String
    created_at: timestamp
    depublish_at: timestamp
    description: String
    header_path: String
    id: uuid
    is_deleted: Boolean
    is_protected: Boolean
    is_public: Boolean
    meta_description: String
    owner_profile: users_profile_obj_rel_insert_input
    "slug van de pagina"
    path: String
    publish_at: timestamp
    published_at: timestamp
    seo_description: String
    seo_image_path: String
    seo_keywords: String
    seo_title: String
    thumbnail_path: String
    title: String
    updated_at: timestamp
    updated_by_profile_id: uuid
    updater_profile: users_profile_obj_rel_insert_input
    user_group_ids: jsonb
    user_profile_id: uuid
}

"append existing jsonb value of filtered columns with new jsonb value"
input cms_content_labels_append_input {
    link_to: jsonb
}

"Boolean expression to filter rows from the table \"cms.content_labels\". All fields are combined with a logical 'AND'."
input cms_content_labels_bool_exp {
    _and: [cms_content_labels_bool_exp!]
    _not: cms_content_labels_bool_exp
    _or: [cms_content_labels_bool_exp!]
    content_content_labels: cms_content_content_labels_bool_exp
    content_type: String_comparison_exp
    created_at: timestamp_comparison_exp
    id: uuid_comparison_exp
    label: String_comparison_exp
    link_to: jsonb_comparison_exp
    updated_at: timestamp_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input cms_content_labels_delete_at_path_input {
    link_to: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input cms_content_labels_delete_elem_input {
    link_to: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input cms_content_labels_delete_key_input {
    link_to: String
}

"input type for inserting data into table \"cms.content_labels\""
input cms_content_labels_insert_input {
    content_content_labels: cms_content_content_labels_arr_rel_insert_input
    content_type: String
    created_at: timestamp
    id: uuid
    label: String
    link_to: jsonb
    updated_at: timestamp
}

"input type for inserting object relation for remote table \"cms.content_labels\""
input cms_content_labels_obj_rel_insert_input {
    data: cms_content_labels_insert_input!
    "on conflict condition"
    on_conflict: cms_content_labels_on_conflict
}

"on conflict condition type for table \"cms.content_labels\""
input cms_content_labels_on_conflict {
    constraint: cms_content_labels_constraint!
    update_columns: [cms_content_labels_update_column!]! = []
    where: cms_content_labels_bool_exp
}

"Ordering options when selecting data from \"cms.content_labels\"."
input cms_content_labels_order_by {
    content_content_labels_aggregate: cms_content_content_labels_aggregate_order_by
    content_type: order_by
    created_at: order_by
    id: order_by
    label: order_by
    link_to: order_by
    updated_at: order_by
}

"primary key columns input for table: cms_content_labels"
input cms_content_labels_pk_columns_input {
    id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input cms_content_labels_prepend_input {
    link_to: jsonb
}

"input type for updating data in table \"cms.content_labels\""
input cms_content_labels_set_input {
    content_type: String
    created_at: timestamp
    id: uuid
    label: String
    link_to: jsonb
    updated_at: timestamp
}

"order by max() on columns of table \"cms.content\""
input cms_content_max_order_by {
    content_type: order_by
    content_width: order_by
    created_at: order_by
    depublish_at: order_by
    description: order_by
    header_path: order_by
    id: order_by
    meta_description: order_by
    "slug van de pagina"
    path: order_by
    publish_at: order_by
    published_at: order_by
    seo_description: order_by
    seo_image_path: order_by
    seo_keywords: order_by
    seo_title: order_by
    thumbnail_path: order_by
    title: order_by
    updated_at: order_by
    updated_by_profile_id: order_by
    user_profile_id: order_by
}

"order by min() on columns of table \"cms.content\""
input cms_content_min_order_by {
    content_type: order_by
    content_width: order_by
    created_at: order_by
    depublish_at: order_by
    description: order_by
    header_path: order_by
    id: order_by
    meta_description: order_by
    "slug van de pagina"
    path: order_by
    publish_at: order_by
    published_at: order_by
    seo_description: order_by
    seo_image_path: order_by
    seo_keywords: order_by
    seo_title: order_by
    thumbnail_path: order_by
    title: order_by
    updated_at: order_by
    updated_by_profile_id: order_by
    user_profile_id: order_by
}

"input type for inserting object relation for remote table \"cms.content\""
input cms_content_obj_rel_insert_input {
    data: cms_content_insert_input!
    "on conflict condition"
    on_conflict: cms_content_on_conflict
}

"on conflict condition type for table \"cms.content\""
input cms_content_on_conflict {
    constraint: cms_content_constraint!
    update_columns: [cms_content_update_column!]! = []
    where: cms_content_bool_exp
}

"Ordering options when selecting data from \"cms.content\"."
input cms_content_order_by {
    content_blocks_aggregate: cms_content_blocks_aggregate_order_by
    content_content_labels_aggregate: cms_content_content_labels_aggregate_order_by
    content_type: order_by
    content_width: order_by
    created_at: order_by
    depublish_at: order_by
    description: order_by
    header_path: order_by
    id: order_by
    is_deleted: order_by
    is_protected: order_by
    is_public: order_by
    meta_description: order_by
    owner_profile: users_profile_order_by
    path: order_by
    publish_at: order_by
    published_at: order_by
    seo_description: order_by
    seo_image_path: order_by
    seo_keywords: order_by
    seo_title: order_by
    thumbnail_path: order_by
    title: order_by
    updated_at: order_by
    updated_by_profile_id: order_by
    updater_profile: users_profile_order_by
    user_group_ids: order_by
    user_profile_id: order_by
}

"primary key columns input for table: cms_content"
input cms_content_pk_columns_input {
    id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input cms_content_prepend_input {
    user_group_ids: jsonb
}

"input type for updating data in table \"cms.content\""
input cms_content_set_input {
    content_type: String
    content_width: String
    created_at: timestamp
    depublish_at: timestamp
    description: String
    header_path: String
    id: uuid
    is_deleted: Boolean
    is_protected: Boolean
    is_public: Boolean
    meta_description: String
    "slug van de pagina"
    path: String
    publish_at: timestamp
    published_at: timestamp
    seo_description: String
    seo_image_path: String
    seo_keywords: String
    seo_title: String
    thumbnail_path: String
    title: String
    updated_at: timestamp
    updated_by_profile_id: uuid
    user_group_ids: jsonb
    user_profile_id: uuid
}

"append existing jsonb value of filtered columns with new jsonb value"
input cms_navigation_element_append_input {
    user_group_ids: jsonb
}

"Boolean expression to filter rows from the table \"cms.navigation_element\". All fields are combined with a logical 'AND'."
input cms_navigation_element_bool_exp {
    _and: [cms_navigation_element_bool_exp!]
    _not: cms_navigation_element_bool_exp
    _or: [cms_navigation_element_bool_exp!]
    content_id: uuid_comparison_exp
    content_path: String_comparison_exp
    content_type: String_comparison_exp
    created_at: timestamptz_comparison_exp
    description: String_comparison_exp
    icon_name: String_comparison_exp
    id: uuid_comparison_exp
    label: String_comparison_exp
    link_target: String_comparison_exp
    placement: String_comparison_exp
    position: Int_comparison_exp
    tooltip: String_comparison_exp
    updated_at: timestamptz_comparison_exp
    user_group_ids: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input cms_navigation_element_delete_at_path_input {
    user_group_ids: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input cms_navigation_element_delete_elem_input {
    user_group_ids: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input cms_navigation_element_delete_key_input {
    user_group_ids: String
}

"input type for incrementing numeric columns in table \"cms.navigation_element\""
input cms_navigation_element_inc_input {
    "volgorde van de links in de navigatie balk 0, 1, 2, 3"
    position: Int
}

"input type for inserting data into table \"cms.navigation_element\""
input cms_navigation_element_insert_input {
    "id van de gelinkte content block pagina"
    content_id: uuid
    content_path: String
    content_type: String
    created_at: timestamptz
    "beschrijving van het navigatie item. enkel zichtbaar voor beheerders"
    description: String
    icon_name: String
    id: uuid
    label: String
    "open in new tab of in zelfde tab"
    link_target: String
    "In welk navigatiemenu verschijnt dit, vb. navigatiemenu linksboven, of footermenu."
    placement: String
    "volgorde van de links in de navigatie balk 0, 1, 2, 3"
    position: Int
    tooltip: String
    updated_at: timestamptz
    user_group_ids: jsonb
}

"on conflict condition type for table \"cms.navigation_element\""
input cms_navigation_element_on_conflict {
    constraint: cms_navigation_element_constraint!
    update_columns: [cms_navigation_element_update_column!]! = []
    where: cms_navigation_element_bool_exp
}

"Ordering options when selecting data from \"cms.navigation_element\"."
input cms_navigation_element_order_by {
    content_id: order_by
    content_path: order_by
    content_type: order_by
    created_at: order_by
    description: order_by
    icon_name: order_by
    id: order_by
    label: order_by
    link_target: order_by
    placement: order_by
    position: order_by
    tooltip: order_by
    updated_at: order_by
    user_group_ids: order_by
}

"primary key columns input for table: cms_navigation_element"
input cms_navigation_element_pk_columns_input {
    id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input cms_navigation_element_prepend_input {
    user_group_ids: jsonb
}

"input type for updating data in table \"cms.navigation_element\""
input cms_navigation_element_set_input {
    "id van de gelinkte content block pagina"
    content_id: uuid
    content_path: String
    content_type: String
    created_at: timestamptz
    "beschrijving van het navigatie item. enkel zichtbaar voor beheerders"
    description: String
    icon_name: String
    id: uuid
    label: String
    "open in new tab of in zelfde tab"
    link_target: String
    "In welk navigatiemenu verschijnt dit, vb. navigatiemenu linksboven, of footermenu."
    placement: String
    "volgorde van de links in de navigatie balk 0, 1, 2, 3"
    position: Int
    tooltip: String
    updated_at: timestamptz
    user_group_ids: jsonb
}

"append existing jsonb value of filtered columns with new jsonb value"
input cms_site_variables_append_input {
    value: jsonb
}

"Boolean expression to filter rows from the table \"cms.site_variables\". All fields are combined with a logical 'AND'."
input cms_site_variables_bool_exp {
    _and: [cms_site_variables_bool_exp!]
    _not: cms_site_variables_bool_exp
    _or: [cms_site_variables_bool_exp!]
    created_at: timestamp_comparison_exp
    name: String_comparison_exp
    updated_at: timestamp_comparison_exp
    value: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input cms_site_variables_delete_at_path_input {
    value: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input cms_site_variables_delete_elem_input {
    value: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input cms_site_variables_delete_key_input {
    value: String
}

"input type for inserting data into table \"cms.site_variables\""
input cms_site_variables_insert_input {
    created_at: timestamp
    name: String
    updated_at: timestamp
    value: jsonb
}

"on conflict condition type for table \"cms.site_variables\""
input cms_site_variables_on_conflict {
    constraint: cms_site_variables_constraint!
    update_columns: [cms_site_variables_update_column!]! = []
    where: cms_site_variables_bool_exp
}

"Ordering options when selecting data from \"cms.site_variables\"."
input cms_site_variables_order_by {
    created_at: order_by
    name: order_by
    updated_at: order_by
    value: order_by
}

"primary key columns input for table: cms_site_variables"
input cms_site_variables_pk_columns_input {
    name: String!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input cms_site_variables_prepend_input {
    value: jsonb
}

"input type for updating data in table \"cms.site_variables\""
input cms_site_variables_set_input {
    created_at: timestamp
    name: String
    updated_at: timestamp
    value: jsonb
}

"Boolean expression to filter rows from the table \"cp.index\". All fields are combined with a logical 'AND'."
input cp_index_bool_exp {
    _and: [cp_index_bool_exp!]
    _not: cp_index_bool_exp
    _or: [cp_index_bool_exp!]
    created_at: timestamp_comparison_exp
    schema_maintainer: cp_maintainer_bool_exp
    schema_maintainer_id: String_comparison_exp
    schema_name: String_comparison_exp
    updated_at: timestamp_comparison_exp
}

"input type for inserting data into table \"cp.index\""
input cp_index_insert_input {
    created_at: timestamp
    schema_maintainer: cp_maintainer_obj_rel_insert_input
    schema_maintainer_id: String
    schema_name: String
    updated_at: timestamp
}

"input type for inserting object relation for remote table \"cp.index\""
input cp_index_obj_rel_insert_input {
    data: cp_index_insert_input!
    "on conflict condition"
    on_conflict: cp_index_on_conflict
}

"on conflict condition type for table \"cp.index\""
input cp_index_on_conflict {
    constraint: cp_index_constraint!
    update_columns: [cp_index_update_column!]! = []
    where: cp_index_bool_exp
}

"Ordering options when selecting data from \"cp.index\"."
input cp_index_order_by {
    created_at: order_by
    schema_maintainer: cp_maintainer_order_by
    schema_maintainer_id: order_by
    schema_name: order_by
    updated_at: order_by
}

"primary key columns input for table: cp_index"
input cp_index_pk_columns_input {
    schema_maintainer_id: String!
}

"input type for updating data in table \"cp.index\""
input cp_index_set_input {
    created_at: timestamp
    schema_maintainer_id: String
    schema_name: String
    updated_at: timestamp
}

"Boolean expression to filter rows from the table \"cp.maintainer\". All fields are combined with a logical 'AND'."
input cp_maintainer_bool_exp {
    _and: [cp_maintainer_bool_exp!]
    _not: cp_maintainer_bool_exp
    _or: [cp_maintainer_bool_exp!]
    created_at: timestamp_comparison_exp
    has_index: Boolean_comparison_exp
    has_space: Boolean_comparison_exp
    ies: object_ie_bool_exp
    index: cp_index_bool_exp
    maintainer_users_profiles: cp_maintainer_users_profile_bool_exp
    schema_identifier: String_comparison_exp
    schema_name: String_comparison_exp
    space: cp_space_bool_exp
    updated_at: timestamp_comparison_exp
}

"input type for inserting data into table \"cp.maintainer\""
input cp_maintainer_insert_input {
    created_at: timestamp
    has_index: Boolean
    has_space: Boolean
    ies: object_ie_arr_rel_insert_input
    index: cp_index_obj_rel_insert_input
    maintainer_users_profiles: cp_maintainer_users_profile_arr_rel_insert_input
    schema_identifier: String
    schema_name: String
    space: cp_space_obj_rel_insert_input
    updated_at: timestamp
}

"input type for inserting object relation for remote table \"cp.maintainer\""
input cp_maintainer_obj_rel_insert_input {
    data: cp_maintainer_insert_input!
    "on conflict condition"
    on_conflict: cp_maintainer_on_conflict
}

"on conflict condition type for table \"cp.maintainer\""
input cp_maintainer_on_conflict {
    constraint: cp_maintainer_constraint!
    update_columns: [cp_maintainer_update_column!]! = []
    where: cp_maintainer_bool_exp
}

"Ordering options when selecting data from \"cp.maintainer\"."
input cp_maintainer_order_by {
    created_at: order_by
    has_index: order_by
    has_space: order_by
    ies_aggregate: object_ie_aggregate_order_by
    index: cp_index_order_by
    maintainer_users_profiles_aggregate: cp_maintainer_users_profile_aggregate_order_by
    schema_identifier: order_by
    schema_name: order_by
    space: cp_space_order_by
    updated_at: order_by
}

"primary key columns input for table: cp_maintainer"
input cp_maintainer_pk_columns_input {
    schema_identifier: String!
}

"input type for updating data in table \"cp.maintainer\""
input cp_maintainer_set_input {
    created_at: timestamp
    has_index: Boolean
    has_space: Boolean
    schema_identifier: String
    schema_name: String
    updated_at: timestamp
}

"order by aggregate values of table \"cp.maintainer_users_profile\""
input cp_maintainer_users_profile_aggregate_order_by {
    count: order_by
    max: cp_maintainer_users_profile_max_order_by
    min: cp_maintainer_users_profile_min_order_by
}

"input type for inserting array relation for remote table \"cp.maintainer_users_profile\""
input cp_maintainer_users_profile_arr_rel_insert_input {
    data: [cp_maintainer_users_profile_insert_input!]!
    "on conflict condition"
    on_conflict: cp_maintainer_users_profile_on_conflict
}

"Boolean expression to filter rows from the table \"cp.maintainer_users_profile\". All fields are combined with a logical 'AND'."
input cp_maintainer_users_profile_bool_exp {
    _and: [cp_maintainer_users_profile_bool_exp!]
    _not: cp_maintainer_users_profile_bool_exp
    _or: [cp_maintainer_users_profile_bool_exp!]
    id: uuid_comparison_exp
    maintainer: cp_maintainer_bool_exp
    maintainer_identifier: String_comparison_exp
    profile: users_profile_bool_exp
    users_profile_id: uuid_comparison_exp
}

"input type for inserting data into table \"cp.maintainer_users_profile\""
input cp_maintainer_users_profile_insert_input {
    id: uuid
    maintainer: cp_maintainer_obj_rel_insert_input
    maintainer_identifier: String
    profile: users_profile_obj_rel_insert_input
    users_profile_id: uuid
}

"order by max() on columns of table \"cp.maintainer_users_profile\""
input cp_maintainer_users_profile_max_order_by {
    id: order_by
    maintainer_identifier: order_by
    users_profile_id: order_by
}

"order by min() on columns of table \"cp.maintainer_users_profile\""
input cp_maintainer_users_profile_min_order_by {
    id: order_by
    maintainer_identifier: order_by
    users_profile_id: order_by
}

"on conflict condition type for table \"cp.maintainer_users_profile\""
input cp_maintainer_users_profile_on_conflict {
    constraint: cp_maintainer_users_profile_constraint!
    update_columns: [cp_maintainer_users_profile_update_column!]! = []
    where: cp_maintainer_users_profile_bool_exp
}

"Ordering options when selecting data from \"cp.maintainer_users_profile\"."
input cp_maintainer_users_profile_order_by {
    id: order_by
    maintainer: cp_maintainer_order_by
    maintainer_identifier: order_by
    profile: users_profile_order_by
    users_profile_id: order_by
}

"primary key columns input for table: cp_maintainer_users_profile"
input cp_maintainer_users_profile_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"cp.maintainer_users_profile\""
input cp_maintainer_users_profile_set_input {
    id: uuid
    maintainer_identifier: String
    users_profile_id: uuid
}

"Boolean expression to filter rows from the table \"cp.space\". All fields are combined with a logical 'AND'."
input cp_space_bool_exp {
    _and: [cp_space_bool_exp!]
    _not: cp_space_bool_exp
    _or: [cp_space_bool_exp!]
    created_at: timestamp_comparison_exp
    id: uuid_comparison_exp
    is_published: Boolean_comparison_exp
    published_at: timestamp_comparison_exp
    schemaAudienceTypeBySchemaAudienceType: lookup_schema_audience_type_bool_exp
    schema_audience_type: lookup_schema_audience_type_enum_comparison_exp
    schema_color: String_comparison_exp
    schema_description: String_comparison_exp
    schema_image: String_comparison_exp
    schema_maintainer: cp_maintainer_bool_exp
    schema_maintainer_id: String_comparison_exp
    schema_public_access: Boolean_comparison_exp
    schema_service_description: String_comparison_exp
    updated_at: timestamp_comparison_exp
    visits: cp_visit_bool_exp
}

"input type for inserting data into table \"cp.space\""
input cp_space_insert_input {
    created_at: timestamp
    id: uuid
    is_published: Boolean
    published_at: timestamp
    schemaAudienceTypeBySchemaAudienceType: lookup_schema_audience_type_obj_rel_insert_input
    schema_audience_type: lookup_schema_audience_type_enum
    schema_color: String
    schema_description: String
    schema_image: String
    schema_maintainer: cp_maintainer_obj_rel_insert_input
    schema_maintainer_id: String
    schema_public_access: Boolean
    schema_service_description: String
    updated_at: timestamp
    visits: cp_visit_arr_rel_insert_input
}

"input type for inserting object relation for remote table \"cp.space\""
input cp_space_obj_rel_insert_input {
    data: cp_space_insert_input!
    "on conflict condition"
    on_conflict: cp_space_on_conflict
}

"on conflict condition type for table \"cp.space\""
input cp_space_on_conflict {
    constraint: cp_space_constraint!
    update_columns: [cp_space_update_column!]! = []
    where: cp_space_bool_exp
}

"Ordering options when selecting data from \"cp.space\"."
input cp_space_order_by {
    created_at: order_by
    id: order_by
    is_published: order_by
    published_at: order_by
    schemaAudienceTypeBySchemaAudienceType: lookup_schema_audience_type_order_by
    schema_audience_type: order_by
    schema_color: order_by
    schema_description: order_by
    schema_image: order_by
    schema_maintainer: cp_maintainer_order_by
    schema_maintainer_id: order_by
    schema_public_access: order_by
    schema_service_description: order_by
    updated_at: order_by
    visits_aggregate: cp_visit_aggregate_order_by
}

"primary key columns input for table: cp_space"
input cp_space_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"cp.space\""
input cp_space_set_input {
    created_at: timestamp
    id: uuid
    is_published: Boolean
    published_at: timestamp
    schema_audience_type: lookup_schema_audience_type_enum
    schema_color: String
    schema_description: String
    schema_image: String
    schema_maintainer_id: String
    schema_public_access: Boolean
    schema_service_description: String
    updated_at: timestamp
}

"order by aggregate values of table \"cp.visit\""
input cp_visit_aggregate_order_by {
    count: order_by
    max: cp_visit_max_order_by
    min: cp_visit_min_order_by
}

"input type for inserting array relation for remote table \"cp.visit\""
input cp_visit_arr_rel_insert_input {
    data: [cp_visit_insert_input!]!
    "on conflict condition"
    on_conflict: cp_visit_on_conflict
}

"Boolean expression to filter rows from the table \"cp.visit\". All fields are combined with a logical 'AND'."
input cp_visit_bool_exp {
    _and: [cp_visit_bool_exp!]
    _not: cp_visit_bool_exp
    _or: [cp_visit_bool_exp!]
    cp_space_id: uuid_comparison_exp
    created_at: timestamp_comparison_exp
    end_date: timestamp_comparison_exp
    id: uuid_comparison_exp
    notes: cp_visit_note_bool_exp
    notifications: app_notification_bool_exp
    space: cp_space_bool_exp
    start_date: timestamp_comparison_exp
    status: String_comparison_exp
    updated_at: timestamp_comparison_exp
    updated_by: uuid_comparison_exp
    updater: users_profile_bool_exp
    user_accepted_tos: Boolean_comparison_exp
    user_profile: users_profile_bool_exp
    user_profile_id: uuid_comparison_exp
    user_reason: String_comparison_exp
    user_timeframe: String_comparison_exp
}

"input type for inserting data into table \"cp.visit\""
input cp_visit_insert_input {
    cp_space_id: uuid
    created_at: timestamp
    end_date: timestamp
    id: uuid
    notes: cp_visit_note_arr_rel_insert_input
    notifications: app_notification_arr_rel_insert_input
    space: cp_space_obj_rel_insert_input
    start_date: timestamp
    status: String
    updated_at: timestamp
    updated_by: uuid
    updater: users_profile_obj_rel_insert_input
    user_accepted_tos: Boolean
    user_profile: users_profile_obj_rel_insert_input
    user_profile_id: uuid
    user_reason: String
    user_timeframe: String
}

"order by max() on columns of table \"cp.visit\""
input cp_visit_max_order_by {
    cp_space_id: order_by
    created_at: order_by
    end_date: order_by
    id: order_by
    start_date: order_by
    status: order_by
    updated_at: order_by
    updated_by: order_by
    user_profile_id: order_by
    user_reason: order_by
    user_timeframe: order_by
}

"order by min() on columns of table \"cp.visit\""
input cp_visit_min_order_by {
    cp_space_id: order_by
    created_at: order_by
    end_date: order_by
    id: order_by
    start_date: order_by
    status: order_by
    updated_at: order_by
    updated_by: order_by
    user_profile_id: order_by
    user_reason: order_by
    user_timeframe: order_by
}

"order by aggregate values of table \"cp.visit_note\""
input cp_visit_note_aggregate_order_by {
    count: order_by
    max: cp_visit_note_max_order_by
    min: cp_visit_note_min_order_by
}

"input type for inserting array relation for remote table \"cp.visit_note\""
input cp_visit_note_arr_rel_insert_input {
    data: [cp_visit_note_insert_input!]!
    "on conflict condition"
    on_conflict: cp_visit_note_on_conflict
}

"Boolean expression to filter rows from the table \"cp.visit_note\". All fields are combined with a logical 'AND'."
input cp_visit_note_bool_exp {
    _and: [cp_visit_note_bool_exp!]
    _not: cp_visit_note_bool_exp
    _or: [cp_visit_note_bool_exp!]
    created_at: timestamp_comparison_exp
    id: uuid_comparison_exp
    note: String_comparison_exp
    profile: users_profile_bool_exp
    profile_id: uuid_comparison_exp
    updated_at: timestamp_comparison_exp
    visit: cp_visit_bool_exp
    visit_id: uuid_comparison_exp
}

"input type for inserting data into table \"cp.visit_note\""
input cp_visit_note_insert_input {
    created_at: timestamp
    id: uuid
    note: String
    profile: users_profile_obj_rel_insert_input
    "Degene die de notitie heeft gemaakt"
    profile_id: uuid
    updated_at: timestamp
    visit: cp_visit_obj_rel_insert_input
    visit_id: uuid
}

"order by max() on columns of table \"cp.visit_note\""
input cp_visit_note_max_order_by {
    created_at: order_by
    id: order_by
    note: order_by
    "Degene die de notitie heeft gemaakt"
    profile_id: order_by
    updated_at: order_by
    visit_id: order_by
}

"order by min() on columns of table \"cp.visit_note\""
input cp_visit_note_min_order_by {
    created_at: order_by
    id: order_by
    note: order_by
    "Degene die de notitie heeft gemaakt"
    profile_id: order_by
    updated_at: order_by
    visit_id: order_by
}

"on conflict condition type for table \"cp.visit_note\""
input cp_visit_note_on_conflict {
    constraint: cp_visit_note_constraint!
    update_columns: [cp_visit_note_update_column!]! = []
    where: cp_visit_note_bool_exp
}

"Ordering options when selecting data from \"cp.visit_note\"."
input cp_visit_note_order_by {
    created_at: order_by
    id: order_by
    note: order_by
    profile: users_profile_order_by
    profile_id: order_by
    updated_at: order_by
    visit: cp_visit_order_by
    visit_id: order_by
}

"primary key columns input for table: cp_visit_note"
input cp_visit_note_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"cp.visit_note\""
input cp_visit_note_set_input {
    created_at: timestamp
    id: uuid
    note: String
    "Degene die de notitie heeft gemaakt"
    profile_id: uuid
    updated_at: timestamp
    visit_id: uuid
}

"input type for inserting object relation for remote table \"cp.visit\""
input cp_visit_obj_rel_insert_input {
    data: cp_visit_insert_input!
    "on conflict condition"
    on_conflict: cp_visit_on_conflict
}

"on conflict condition type for table \"cp.visit\""
input cp_visit_on_conflict {
    constraint: cp_visit_constraint!
    update_columns: [cp_visit_update_column!]! = []
    where: cp_visit_bool_exp
}

"Ordering options when selecting data from \"cp.visit\"."
input cp_visit_order_by {
    cp_space_id: order_by
    created_at: order_by
    end_date: order_by
    id: order_by
    notes_aggregate: cp_visit_note_aggregate_order_by
    notifications_aggregate: app_notification_aggregate_order_by
    space: cp_space_order_by
    start_date: order_by
    status: order_by
    updated_at: order_by
    updated_by: order_by
    updater: users_profile_order_by
    user_accepted_tos: order_by
    user_profile: users_profile_order_by
    user_profile_id: order_by
    user_reason: order_by
    user_timeframe: order_by
}

"primary key columns input for table: cp_visit"
input cp_visit_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"cp.visit\""
input cp_visit_set_input {
    cp_space_id: uuid
    created_at: timestamp
    end_date: timestamp
    id: uuid
    start_date: timestamp
    status: String
    updated_at: timestamp
    updated_by: uuid
    user_accepted_tos: Boolean
    user_profile_id: uuid
    user_reason: String
    user_timeframe: String
}

"Boolean expression to compare columns of type \"date\". All fields are combined with logical 'AND'."
input date_comparison_exp {
    _eq: date
    _gt: date
    _gte: date
    _in: [date!]
    _is_null: Boolean
    _lt: date
    _lte: date
    _neq: date
    _nin: [date!]
}

"Boolean expression to compare columns of type \"daterange\". All fields are combined with logical 'AND'."
input daterange_comparison_exp {
    _eq: daterange
    _gt: daterange
    _gte: daterange
    _in: [daterange!]
    _is_null: Boolean
    _lt: daterange
    _lte: daterange
    _neq: daterange
    _nin: [daterange!]
}

"Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
    "is the column contained in the given json value"
    _contained_in: jsonb
    "does the column contain the given json value at the top level"
    _contains: jsonb
    _eq: jsonb
    _gt: jsonb
    _gte: jsonb
    "does the string exist as a top-level key in the column"
    _has_key: String
    "do all of these strings exist as top-level keys in the column"
    _has_keys_all: [String!]
    "do any of these strings exist as top-level keys in the column"
    _has_keys_any: [String!]
    _in: [jsonb!]
    _is_null: Boolean
    _lt: jsonb
    _lte: jsonb
    _neq: jsonb
    _nin: [jsonb!]
}

"Boolean expression to filter rows from the table \"lookup.app_notification_type\". All fields are combined with a logical 'AND'."
input lookup_app_notification_type_bool_exp {
    _and: [lookup_app_notification_type_bool_exp!]
    _not: lookup_app_notification_type_bool_exp
    _or: [lookup_app_notification_type_bool_exp!]
    comment: String_comparison_exp
    value: String_comparison_exp
}

"input type for inserting data into table \"lookup.app_notification_type\""
input lookup_app_notification_type_insert_input {
    comment: String
    value: String
}

"on conflict condition type for table \"lookup.app_notification_type\""
input lookup_app_notification_type_on_conflict {
    constraint: lookup_app_notification_type_constraint!
    update_columns: [lookup_app_notification_type_update_column!]! = []
    where: lookup_app_notification_type_bool_exp
}

"Ordering options when selecting data from \"lookup.app_notification_type\"."
input lookup_app_notification_type_order_by {
    comment: order_by
    value: order_by
}

"primary key columns input for table: lookup_app_notification_type"
input lookup_app_notification_type_pk_columns_input {
    value: String!
}

"input type for updating data in table \"lookup.app_notification_type\""
input lookup_app_notification_type_set_input {
    comment: String
    value: String
}

"Boolean expression to filter rows from the table \"lookup.cms_content_block_type\". All fields are combined with a logical 'AND'."
input lookup_cms_content_block_type_bool_exp {
    _and: [lookup_cms_content_block_type_bool_exp!]
    _not: lookup_cms_content_block_type_bool_exp
    _or: [lookup_cms_content_block_type_bool_exp!]
    description: String_comparison_exp
    value: String_comparison_exp
}

"input type for inserting data into table \"lookup.cms_content_block_type\""
input lookup_cms_content_block_type_insert_input {
    description: String
    value: String
}

"on conflict condition type for table \"lookup.cms_content_block_type\""
input lookup_cms_content_block_type_on_conflict {
    constraint: lookup_cms_content_block_type_constraint!
    update_columns: [lookup_cms_content_block_type_update_column!]! = []
    where: lookup_cms_content_block_type_bool_exp
}

"Ordering options when selecting data from \"lookup.cms_content_block_type\"."
input lookup_cms_content_block_type_order_by {
    description: order_by
    value: order_by
}

"primary key columns input for table: lookup_cms_content_block_type"
input lookup_cms_content_block_type_pk_columns_input {
    value: String!
}

"input type for updating data in table \"lookup.cms_content_block_type\""
input lookup_cms_content_block_type_set_input {
    description: String
    value: String
}

"Boolean expression to filter rows from the table \"lookup.cms_content_type\". All fields are combined with a logical 'AND'."
input lookup_cms_content_type_bool_exp {
    _and: [lookup_cms_content_type_bool_exp!]
    _not: lookup_cms_content_type_bool_exp
    _or: [lookup_cms_content_type_bool_exp!]
    description: String_comparison_exp
    value: String_comparison_exp
}

"input type for inserting data into table \"lookup.cms_content_type\""
input lookup_cms_content_type_insert_input {
    description: String
    value: String
}

"on conflict condition type for table \"lookup.cms_content_type\""
input lookup_cms_content_type_on_conflict {
    constraint: lookup_cms_content_type_constraint!
    update_columns: [lookup_cms_content_type_update_column!]! = []
    where: lookup_cms_content_type_bool_exp
}

"Ordering options when selecting data from \"lookup.cms_content_type\"."
input lookup_cms_content_type_order_by {
    description: order_by
    value: order_by
}

"primary key columns input for table: lookup_cms_content_type"
input lookup_cms_content_type_pk_columns_input {
    value: String!
}

"input type for updating data in table \"lookup.cms_content_type\""
input lookup_cms_content_type_set_input {
    description: String
    value: String
}

"Boolean expression to filter rows from the table \"lookup.cp_visit_status\". All fields are combined with a logical 'AND'."
input lookup_cp_visit_status_bool_exp {
    _and: [lookup_cp_visit_status_bool_exp!]
    _not: lookup_cp_visit_status_bool_exp
    _or: [lookup_cp_visit_status_bool_exp!]
    comment: String_comparison_exp
    value: String_comparison_exp
}

"input type for inserting data into table \"lookup.cp_visit_status\""
input lookup_cp_visit_status_insert_input {
    comment: String
    value: String
}

"on conflict condition type for table \"lookup.cp_visit_status\""
input lookup_cp_visit_status_on_conflict {
    constraint: lookup_cp_visit_status_constraint!
    update_columns: [lookup_cp_visit_status_update_column!]! = []
    where: lookup_cp_visit_status_bool_exp
}

"Ordering options when selecting data from \"lookup.cp_visit_status\"."
input lookup_cp_visit_status_order_by {
    comment: order_by
    value: order_by
}

"primary key columns input for table: lookup_cp_visit_status"
input lookup_cp_visit_status_pk_columns_input {
    value: String!
}

"input type for updating data in table \"lookup.cp_visit_status\""
input lookup_cp_visit_status_set_input {
    comment: String
    value: String
}

"Boolean expression to filter rows from the table \"lookup.schema_audience_type\". All fields are combined with a logical 'AND'."
input lookup_schema_audience_type_bool_exp {
    _and: [lookup_schema_audience_type_bool_exp!]
    _not: lookup_schema_audience_type_bool_exp
    _or: [lookup_schema_audience_type_bool_exp!]
    comment: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"lookup_schema_audience_type_enum\". All fields are combined with logical 'AND'."
input lookup_schema_audience_type_enum_comparison_exp {
    _eq: lookup_schema_audience_type_enum
    _in: [lookup_schema_audience_type_enum!]
    _is_null: Boolean
    _neq: lookup_schema_audience_type_enum
    _nin: [lookup_schema_audience_type_enum!]
}

"input type for inserting data into table \"lookup.schema_audience_type\""
input lookup_schema_audience_type_insert_input {
    comment: String
    value: String
}

"input type for inserting object relation for remote table \"lookup.schema_audience_type\""
input lookup_schema_audience_type_obj_rel_insert_input {
    data: lookup_schema_audience_type_insert_input!
    "on conflict condition"
    on_conflict: lookup_schema_audience_type_on_conflict
}

"on conflict condition type for table \"lookup.schema_audience_type\""
input lookup_schema_audience_type_on_conflict {
    constraint: lookup_schema_audience_type_constraint!
    update_columns: [lookup_schema_audience_type_update_column!]! = []
    where: lookup_schema_audience_type_bool_exp
}

"Ordering options when selecting data from \"lookup.schema_audience_type\"."
input lookup_schema_audience_type_order_by {
    comment: order_by
    value: order_by
}

"primary key columns input for table: lookup_schema_audience_type"
input lookup_schema_audience_type_pk_columns_input {
    value: String!
}

"input type for updating data in table \"lookup.schema_audience_type\""
input lookup_schema_audience_type_set_input {
    comment: String
    value: String
}

"order by aggregate values of table \"object.file\""
input object_file_aggregate_order_by {
    count: order_by
    max: object_file_max_order_by
    min: object_file_min_order_by
}

"input type for inserting array relation for remote table \"object.file\""
input object_file_arr_rel_insert_input {
    data: [object_file_insert_input!]!
    "on conflict condition"
    on_conflict: object_file_on_conflict
}

"Boolean expression to filter rows from the table \"object.file\". All fields are combined with a logical 'AND'."
input object_file_bool_exp {
    _and: [object_file_bool_exp!]
    _not: object_file_bool_exp
    _or: [object_file_bool_exp!]
    ebucore_is_media_fragment_of: String_comparison_exp
    ebucore_media_type: String_comparison_exp
    id: String_comparison_exp
    premis_is_included_in: object_representation_bool_exp
    representation_id: String_comparison_exp
    schema_alternate_name: String_comparison_exp
    schema_description: String_comparison_exp
    schema_embed_url: String_comparison_exp
    schema_name: String_comparison_exp
}

"input type for inserting data into table \"object.file\""
input object_file_insert_input {
    ebucore_is_media_fragment_of: String
    ebucore_media_type: String
    id: String
    premis_is_included_in: object_representation_obj_rel_insert_input
    representation_id: String
    schema_alternate_name: String
    schema_description: String
    schema_embed_url: String
    schema_name: String
}

"order by max() on columns of table \"object.file\""
input object_file_max_order_by {
    ebucore_is_media_fragment_of: order_by
    ebucore_media_type: order_by
    id: order_by
    representation_id: order_by
    schema_alternate_name: order_by
    schema_description: order_by
    schema_embed_url: order_by
    schema_name: order_by
}

"order by min() on columns of table \"object.file\""
input object_file_min_order_by {
    ebucore_is_media_fragment_of: order_by
    ebucore_media_type: order_by
    id: order_by
    representation_id: order_by
    schema_alternate_name: order_by
    schema_description: order_by
    schema_embed_url: order_by
    schema_name: order_by
}

"on conflict condition type for table \"object.file\""
input object_file_on_conflict {
    constraint: object_file_constraint!
    update_columns: [object_file_update_column!]! = []
    where: object_file_bool_exp
}

"Ordering options when selecting data from \"object.file\"."
input object_file_order_by {
    ebucore_is_media_fragment_of: order_by
    ebucore_media_type: order_by
    id: order_by
    premis_is_included_in: object_representation_order_by
    representation_id: order_by
    schema_alternate_name: order_by
    schema_description: order_by
    schema_embed_url: order_by
    schema_name: order_by
}

"primary key columns input for table: object_file"
input object_file_pk_columns_input {
    id: String!
}

"input type for updating data in table \"object.file\""
input object_file_set_input {
    ebucore_is_media_fragment_of: String
    ebucore_media_type: String
    id: String
    representation_id: String
    schema_alternate_name: String
    schema_description: String
    schema_embed_url: String
    schema_name: String
}

"order by aggregate values of table \"object.ie\""
input object_ie_aggregate_order_by {
    avg: object_ie_avg_order_by
    count: order_by
    max: object_ie_max_order_by
    min: object_ie_min_order_by
    stddev: object_ie_stddev_order_by
    stddev_pop: object_ie_stddev_pop_order_by
    stddev_samp: object_ie_stddev_samp_order_by
    sum: object_ie_sum_order_by
    var_pop: object_ie_var_pop_order_by
    var_samp: object_ie_var_samp_order_by
    variance: object_ie_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input object_ie_append_input {
    "Overige lokale identifiers van de Content Partner (json)"
    premis_identifier: jsonb
    "Personen die geacteerd of anderzijds deelgenomen hebben in de IE"
    schema_actor: jsonb
    "Personen die op een andere wijze hebben bijgedragen aan de IE"
    schema_contributor: jsonb
    "Personen die hebben bijgedragen aan de creatie van de IE, aka author"
    schema_creator: jsonb
    schema_is_part_of: jsonb
    "De meemoolicenties op de betreffende IE"
    schema_license: jsonb
    "Persoon of organisatie die verantwoordelijk was voor de publicatie van de IE"
    schema_publisher: jsonb
}

"input type for inserting array relation for remote table \"object.ie\""
input object_ie_arr_rel_insert_input {
    data: [object_ie_insert_input!]!
    "on conflict condition"
    on_conflict: object_ie_on_conflict
}

"order by avg() on columns of table \"object.ie\""
input object_ie_avg_order_by {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: order_by
    "Aantal paginas van geschreven media"
    schema_number_of_pages: order_by
}

"Boolean expression to filter rows from the table \"object.ie\". All fields are combined with a logical 'AND'."
input object_ie_bool_exp {
    _and: [object_ie_bool_exp!]
    _not: object_ie_bool_exp
    _or: [object_ie_bool_exp!]
    collection_ies: users_collection_ie_bool_exp
    dcterms_available: timestamp_comparison_exp
    dcterms_created: String_comparison_exp
    dcterms_format: String_comparison_exp
    dcterms_issued: String_comparison_exp
    dcterms_medium: String_comparison_exp
    ebucore_object_type: String_comparison_exp
    maintainer: cp_maintainer_bool_exp
    meemoo_fragment_id: String_comparison_exp
    meemoo_media_object_id: String_comparison_exp
    meemoofilm_base: String_comparison_exp
    meemoofilm_color: Boolean_comparison_exp
    meemoofilm_contains_embedded_caption: Boolean_comparison_exp
    meemoofilm_embeddedCaptionLanguage: String_comparison_exp
    meemoofilm_image_or_sound: String_comparison_exp
    premis_identifier: jsonb_comparison_exp
    premis_is_part_of: String_comparison_exp
    premis_is_represented_by: object_representation_bool_exp
    premis_relationship: String_comparison_exp
    schema_abstract: String_comparison_exp
    schema_actor: jsonb_comparison_exp
    schema_alternate_name: String_comparison_exp
    schema_contributor: jsonb_comparison_exp
    schema_copyright_holder: String_comparison_exp
    schema_copyright_notice: String_comparison_exp
    schema_creator: jsonb_comparison_exp
    schema_date_created: daterange_comparison_exp
    schema_date_created_lower_bound: date_comparison_exp
    schema_date_published: date_comparison_exp
    schema_description: String_comparison_exp
    schema_duration: time_comparison_exp
    schema_duration_in_seconds: Int_comparison_exp
    schema_genre: _text_comparison_exp
    schema_identifier: String_comparison_exp
    schema_in_language: _text_comparison_exp
    schema_is_part_of: jsonb_comparison_exp
    schema_keywords: _text_comparison_exp
    schema_license: jsonb_comparison_exp
    schema_maintainer_id: String_comparison_exp
    schema_maintainer_id_lower: String_comparison_exp
    schema_name: String_comparison_exp
    schema_number_of_pages: Int_comparison_exp
    schema_part_of_archive: _text_comparison_exp
    schema_part_of_episode: _text_comparison_exp
    schema_part_of_season: _text_comparison_exp
    schema_part_of_series: _text_comparison_exp
    schema_publisher: jsonb_comparison_exp
    schema_spatial_coverage: _text_comparison_exp
    schema_temporal_coverage: _text_comparison_exp
    schema_thumbnail_url: String_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input object_ie_delete_at_path_input {
    "Overige lokale identifiers van de Content Partner (json)"
    premis_identifier: [String!]
    "Personen die geacteerd of anderzijds deelgenomen hebben in de IE"
    schema_actor: [String!]
    "Personen die op een andere wijze hebben bijgedragen aan de IE"
    schema_contributor: [String!]
    "Personen die hebben bijgedragen aan de creatie van de IE, aka author"
    schema_creator: [String!]
    schema_is_part_of: [String!]
    "De meemoolicenties op de betreffende IE"
    schema_license: [String!]
    "Persoon of organisatie die verantwoordelijk was voor de publicatie van de IE"
    schema_publisher: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input object_ie_delete_elem_input {
    "Overige lokale identifiers van de Content Partner (json)"
    premis_identifier: Int
    "Personen die geacteerd of anderzijds deelgenomen hebben in de IE"
    schema_actor: Int
    "Personen die op een andere wijze hebben bijgedragen aan de IE"
    schema_contributor: Int
    "Personen die hebben bijgedragen aan de creatie van de IE, aka author"
    schema_creator: Int
    schema_is_part_of: Int
    "De meemoolicenties op de betreffende IE"
    schema_license: Int
    "Persoon of organisatie die verantwoordelijk was voor de publicatie van de IE"
    schema_publisher: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input object_ie_delete_key_input {
    "Overige lokale identifiers van de Content Partner (json)"
    premis_identifier: String
    "Personen die geacteerd of anderzijds deelgenomen hebben in de IE"
    schema_actor: String
    "Personen die op een andere wijze hebben bijgedragen aan de IE"
    schema_contributor: String
    "Personen die hebben bijgedragen aan de creatie van de IE, aka author"
    schema_creator: String
    schema_is_part_of: String
    "De meemoolicenties op de betreffende IE"
    schema_license: String
    "Persoon of organisatie die verantwoordelijk was voor de publicatie van de IE"
    schema_publisher: String
}

"input type for incrementing numeric columns in table \"object.ie\""
input object_ie_inc_input {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: Int
    "Aantal paginas van geschreven media"
    schema_number_of_pages: Int
}

"input type for inserting data into table \"object.ie\""
input object_ie_insert_input {
    collection_ies: users_collection_ie_arr_rel_insert_input
    "Datum waarop de IE beschikbaar is gemaakt"
    dcterms_available: timestamp
    "De datum waarop de IE werd gemaakt in edtf"
    dcterms_created: String
    "Het mediatype: video, audio, beeld, document, ..."
    dcterms_format: String
    "De datum waarop de IE werd uitgebracht in edtf"
    dcterms_issued: String
    dcterms_medium: String
    ebucore_object_type: String
    maintainer: cp_maintainer_obj_rel_insert_input
    "de unieke fragmentid in mediahaven"
    meemoo_fragment_id: String
    meemoo_media_object_id: String
    meemoofilm_base: String
    meemoofilm_color: Boolean
    meemoofilm_contains_embedded_caption: Boolean
    meemoofilm_embeddedCaptionLanguage: String
    meemoofilm_image_or_sound: String
    "Overige lokale identifiers van de Content Partner (json)"
    premis_identifier: jsonb
    "Maakt deel uit van een andere IE"
    premis_is_part_of: String
    premis_is_represented_by: object_representation_arr_rel_insert_input
    "Is verwant aan een andere IE"
    premis_relationship: String
    "De inhoudelijke samenvatting van de IE"
    schema_abstract: String
    "Personen die geacteerd of anderzijds deelgenomen hebben in de IE"
    schema_actor: jsonb
    "Een alternatieve titel of naam van de IE"
    schema_alternate_name: String
    "Personen die op een andere wijze hebben bijgedragen aan de IE"
    schema_contributor: jsonb
    "De naam of ID van de rechtenhoudende persoon of organisatie"
    schema_copyright_holder: String
    "Opmerkingen bij rechten en hergebruik"
    schema_copyright_notice: String
    "Personen die hebben bijgedragen aan de creatie van de IE, aka author"
    schema_creator: jsonb
    "Datum waarop de IE werd aangemaakt"
    schema_date_created: daterange
    schema_date_created_lower_bound: date
    "Datum waarop de IE voor het eerst werd uitgegeven, uitgezonden of vertoond"
    schema_date_published: date
    "Een korte omschrijving van de IE"
    schema_description: String
    schema_duration: time
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: Int
    schema_genre: _text
    "De meemoo identifier voor een IE"
    schema_identifier: String
    "De taal of talen die in de IE gebruikt worden"
    schema_in_language: _text
    schema_is_part_of: jsonb
    "Tags of sleutelwoorden die de IE omschrijven"
    schema_keywords: _text
    "De meemoolicenties op de betreffende IE"
    schema_license: jsonb
    "De ID van de beherende instelling of aanbieder van de IE, aka de CP (tbv relatie met org API v2)"
    schema_maintainer_id: String
    schema_maintainer_id_lower: String
    "De primaire titel van de IE"
    schema_name: String
    "Aantal paginas van geschreven media"
    schema_number_of_pages: Int
    schema_part_of_archive: _text
    "Aflevering"
    schema_part_of_episode: _text
    "Seizoen"
    schema_part_of_season: _text
    "Serie"
    schema_part_of_series: _text
    "Persoon of organisatie die verantwoordelijk was voor de publicatie van de IE"
    schema_publisher: jsonb
    "Plaatsen of locaties waarover de IE handelt of betrekking op heeft"
    schema_spatial_coverage: _text
    "Datums, tijdstippen of periodes waarover de IE handelt of betrekking op heeft"
    schema_temporal_coverage: _text
    "Een URL naar een thumbnail of placeholder voor de IE"
    schema_thumbnail_url: String
    updated_at: timestamptz
}

"order by max() on columns of table \"object.ie\""
input object_ie_max_order_by {
    "Datum waarop de IE beschikbaar is gemaakt"
    dcterms_available: order_by
    "De datum waarop de IE werd gemaakt in edtf"
    dcterms_created: order_by
    "Het mediatype: video, audio, beeld, document, ..."
    dcterms_format: order_by
    "De datum waarop de IE werd uitgebracht in edtf"
    dcterms_issued: order_by
    dcterms_medium: order_by
    ebucore_object_type: order_by
    "de unieke fragmentid in mediahaven"
    meemoo_fragment_id: order_by
    meemoo_media_object_id: order_by
    meemoofilm_base: order_by
    meemoofilm_embeddedCaptionLanguage: order_by
    meemoofilm_image_or_sound: order_by
    "Maakt deel uit van een andere IE"
    premis_is_part_of: order_by
    "Is verwant aan een andere IE"
    premis_relationship: order_by
    "De inhoudelijke samenvatting van de IE"
    schema_abstract: order_by
    "Een alternatieve titel of naam van de IE"
    schema_alternate_name: order_by
    "De naam of ID van de rechtenhoudende persoon of organisatie"
    schema_copyright_holder: order_by
    "Opmerkingen bij rechten en hergebruik"
    schema_copyright_notice: order_by
    schema_date_created_lower_bound: order_by
    "Datum waarop de IE voor het eerst werd uitgegeven, uitgezonden of vertoond"
    schema_date_published: order_by
    "Een korte omschrijving van de IE"
    schema_description: order_by
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: order_by
    "De meemoo identifier voor een IE"
    schema_identifier: order_by
    "De ID van de beherende instelling of aanbieder van de IE, aka de CP (tbv relatie met org API v2)"
    schema_maintainer_id: order_by
    schema_maintainer_id_lower: order_by
    "De primaire titel van de IE"
    schema_name: order_by
    "Aantal paginas van geschreven media"
    schema_number_of_pages: order_by
    "Een URL naar een thumbnail of placeholder voor de IE"
    schema_thumbnail_url: order_by
    updated_at: order_by
}

"order by min() on columns of table \"object.ie\""
input object_ie_min_order_by {
    "Datum waarop de IE beschikbaar is gemaakt"
    dcterms_available: order_by
    "De datum waarop de IE werd gemaakt in edtf"
    dcterms_created: order_by
    "Het mediatype: video, audio, beeld, document, ..."
    dcterms_format: order_by
    "De datum waarop de IE werd uitgebracht in edtf"
    dcterms_issued: order_by
    dcterms_medium: order_by
    ebucore_object_type: order_by
    "de unieke fragmentid in mediahaven"
    meemoo_fragment_id: order_by
    meemoo_media_object_id: order_by
    meemoofilm_base: order_by
    meemoofilm_embeddedCaptionLanguage: order_by
    meemoofilm_image_or_sound: order_by
    "Maakt deel uit van een andere IE"
    premis_is_part_of: order_by
    "Is verwant aan een andere IE"
    premis_relationship: order_by
    "De inhoudelijke samenvatting van de IE"
    schema_abstract: order_by
    "Een alternatieve titel of naam van de IE"
    schema_alternate_name: order_by
    "De naam of ID van de rechtenhoudende persoon of organisatie"
    schema_copyright_holder: order_by
    "Opmerkingen bij rechten en hergebruik"
    schema_copyright_notice: order_by
    schema_date_created_lower_bound: order_by
    "Datum waarop de IE voor het eerst werd uitgegeven, uitgezonden of vertoond"
    schema_date_published: order_by
    "Een korte omschrijving van de IE"
    schema_description: order_by
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: order_by
    "De meemoo identifier voor een IE"
    schema_identifier: order_by
    "De ID van de beherende instelling of aanbieder van de IE, aka de CP (tbv relatie met org API v2)"
    schema_maintainer_id: order_by
    schema_maintainer_id_lower: order_by
    "De primaire titel van de IE"
    schema_name: order_by
    "Aantal paginas van geschreven media"
    schema_number_of_pages: order_by
    "Een URL naar een thumbnail of placeholder voor de IE"
    schema_thumbnail_url: order_by
    updated_at: order_by
}

"input type for inserting object relation for remote table \"object.ie\""
input object_ie_obj_rel_insert_input {
    data: object_ie_insert_input!
    "on conflict condition"
    on_conflict: object_ie_on_conflict
}

"on conflict condition type for table \"object.ie\""
input object_ie_on_conflict {
    constraint: object_ie_constraint!
    update_columns: [object_ie_update_column!]! = []
    where: object_ie_bool_exp
}

"Ordering options when selecting data from \"object.ie\"."
input object_ie_order_by {
    collection_ies_aggregate: users_collection_ie_aggregate_order_by
    dcterms_available: order_by
    dcterms_created: order_by
    dcterms_format: order_by
    dcterms_issued: order_by
    dcterms_medium: order_by
    ebucore_object_type: order_by
    maintainer: cp_maintainer_order_by
    meemoo_fragment_id: order_by
    meemoo_media_object_id: order_by
    meemoofilm_base: order_by
    meemoofilm_color: order_by
    meemoofilm_contains_embedded_caption: order_by
    meemoofilm_embeddedCaptionLanguage: order_by
    meemoofilm_image_or_sound: order_by
    premis_identifier: order_by
    premis_is_part_of: order_by
    premis_is_represented_by_aggregate: object_representation_aggregate_order_by
    premis_relationship: order_by
    schema_abstract: order_by
    schema_actor: order_by
    schema_alternate_name: order_by
    schema_contributor: order_by
    schema_copyright_holder: order_by
    schema_copyright_notice: order_by
    schema_creator: order_by
    schema_date_created: order_by
    schema_date_created_lower_bound: order_by
    schema_date_published: order_by
    schema_description: order_by
    schema_duration: order_by
    schema_duration_in_seconds: order_by
    schema_genre: order_by
    schema_identifier: order_by
    schema_in_language: order_by
    schema_is_part_of: order_by
    schema_keywords: order_by
    schema_license: order_by
    schema_maintainer_id: order_by
    schema_maintainer_id_lower: order_by
    schema_name: order_by
    schema_number_of_pages: order_by
    schema_part_of_archive: order_by
    schema_part_of_episode: order_by
    schema_part_of_season: order_by
    schema_part_of_series: order_by
    schema_publisher: order_by
    schema_spatial_coverage: order_by
    schema_temporal_coverage: order_by
    schema_thumbnail_url: order_by
    updated_at: order_by
}

"primary key columns input for table: object_ie"
input object_ie_pk_columns_input {
    "de unieke fragmentid in mediahaven"
    meemoo_fragment_id: String!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input object_ie_prepend_input {
    "Overige lokale identifiers van de Content Partner (json)"
    premis_identifier: jsonb
    "Personen die geacteerd of anderzijds deelgenomen hebben in de IE"
    schema_actor: jsonb
    "Personen die op een andere wijze hebben bijgedragen aan de IE"
    schema_contributor: jsonb
    "Personen die hebben bijgedragen aan de creatie van de IE, aka author"
    schema_creator: jsonb
    schema_is_part_of: jsonb
    "De meemoolicenties op de betreffende IE"
    schema_license: jsonb
    "Persoon of organisatie die verantwoordelijk was voor de publicatie van de IE"
    schema_publisher: jsonb
}

"input type for updating data in table \"object.ie\""
input object_ie_set_input {
    "Datum waarop de IE beschikbaar is gemaakt"
    dcterms_available: timestamp
    "De datum waarop de IE werd gemaakt in edtf"
    dcterms_created: String
    "Het mediatype: video, audio, beeld, document, ..."
    dcterms_format: String
    "De datum waarop de IE werd uitgebracht in edtf"
    dcterms_issued: String
    dcterms_medium: String
    ebucore_object_type: String
    "de unieke fragmentid in mediahaven"
    meemoo_fragment_id: String
    meemoo_media_object_id: String
    meemoofilm_base: String
    meemoofilm_color: Boolean
    meemoofilm_contains_embedded_caption: Boolean
    meemoofilm_embeddedCaptionLanguage: String
    meemoofilm_image_or_sound: String
    "Overige lokale identifiers van de Content Partner (json)"
    premis_identifier: jsonb
    "Maakt deel uit van een andere IE"
    premis_is_part_of: String
    "Is verwant aan een andere IE"
    premis_relationship: String
    "De inhoudelijke samenvatting van de IE"
    schema_abstract: String
    "Personen die geacteerd of anderzijds deelgenomen hebben in de IE"
    schema_actor: jsonb
    "Een alternatieve titel of naam van de IE"
    schema_alternate_name: String
    "Personen die op een andere wijze hebben bijgedragen aan de IE"
    schema_contributor: jsonb
    "De naam of ID van de rechtenhoudende persoon of organisatie"
    schema_copyright_holder: String
    "Opmerkingen bij rechten en hergebruik"
    schema_copyright_notice: String
    "Personen die hebben bijgedragen aan de creatie van de IE, aka author"
    schema_creator: jsonb
    "Datum waarop de IE werd aangemaakt"
    schema_date_created: daterange
    schema_date_created_lower_bound: date
    "Datum waarop de IE voor het eerst werd uitgegeven, uitgezonden of vertoond"
    schema_date_published: date
    "Een korte omschrijving van de IE"
    schema_description: String
    schema_duration: time
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: Int
    schema_genre: _text
    "De meemoo identifier voor een IE"
    schema_identifier: String
    "De taal of talen die in de IE gebruikt worden"
    schema_in_language: _text
    schema_is_part_of: jsonb
    "Tags of sleutelwoorden die de IE omschrijven"
    schema_keywords: _text
    "De meemoolicenties op de betreffende IE"
    schema_license: jsonb
    "De ID van de beherende instelling of aanbieder van de IE, aka de CP (tbv relatie met org API v2)"
    schema_maintainer_id: String
    schema_maintainer_id_lower: String
    "De primaire titel van de IE"
    schema_name: String
    "Aantal paginas van geschreven media"
    schema_number_of_pages: Int
    schema_part_of_archive: _text
    "Aflevering"
    schema_part_of_episode: _text
    "Seizoen"
    schema_part_of_season: _text
    "Serie"
    schema_part_of_series: _text
    "Persoon of organisatie die verantwoordelijk was voor de publicatie van de IE"
    schema_publisher: jsonb
    "Plaatsen of locaties waarover de IE handelt of betrekking op heeft"
    schema_spatial_coverage: _text
    "Datums, tijdstippen of periodes waarover de IE handelt of betrekking op heeft"
    schema_temporal_coverage: _text
    "Een URL naar een thumbnail of placeholder voor de IE"
    schema_thumbnail_url: String
    updated_at: timestamptz
}

"order by stddev() on columns of table \"object.ie\""
input object_ie_stddev_order_by {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: order_by
    "Aantal paginas van geschreven media"
    schema_number_of_pages: order_by
}

"order by stddev_pop() on columns of table \"object.ie\""
input object_ie_stddev_pop_order_by {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: order_by
    "Aantal paginas van geschreven media"
    schema_number_of_pages: order_by
}

"order by stddev_samp() on columns of table \"object.ie\""
input object_ie_stddev_samp_order_by {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: order_by
    "Aantal paginas van geschreven media"
    schema_number_of_pages: order_by
}

"order by sum() on columns of table \"object.ie\""
input object_ie_sum_order_by {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: order_by
    "Aantal paginas van geschreven media"
    schema_number_of_pages: order_by
}

"order by var_pop() on columns of table \"object.ie\""
input object_ie_var_pop_order_by {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: order_by
    "Aantal paginas van geschreven media"
    schema_number_of_pages: order_by
}

"order by var_samp() on columns of table \"object.ie\""
input object_ie_var_samp_order_by {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: order_by
    "Aantal paginas van geschreven media"
    schema_number_of_pages: order_by
}

"order by variance() on columns of table \"object.ie\""
input object_ie_variance_order_by {
    "Tijd in seconden van tijdsgebaseerde media."
    schema_duration_in_seconds: order_by
    "Aantal paginas van geschreven media"
    schema_number_of_pages: order_by
}

"order by aggregate values of table \"object.representation\""
input object_representation_aggregate_order_by {
    count: order_by
    max: object_representation_max_order_by
    min: object_representation_min_order_by
}

"input type for inserting array relation for remote table \"object.representation\""
input object_representation_arr_rel_insert_input {
    data: [object_representation_insert_input!]!
    "on conflict condition"
    on_conflict: object_representation_on_conflict
}

"Boolean expression to filter rows from the table \"object.representation\". All fields are combined with a logical 'AND'."
input object_representation_bool_exp {
    _and: [object_representation_bool_exp!]
    _not: object_representation_bool_exp
    _or: [object_representation_bool_exp!]
    dcterms_format: String_comparison_exp
    id: String_comparison_exp
    ie_meemoo_fragment_id: String_comparison_exp
    premis_includes: object_file_bool_exp
    premis_represents: object_ie_bool_exp
    schema_alternate_name: String_comparison_exp
    schema_date_created: timestamp_comparison_exp
    schema_description: String_comparison_exp
    schema_name: String_comparison_exp
    schema_transcript: String_comparison_exp
}

"input type for inserting data into table \"object.representation\""
input object_representation_insert_input {
    "het bestandstype van de represenatatie, container"
    dcterms_format: String
    id: String
    "de FragmentId van de IE waarvan dit de representation is"
    ie_meemoo_fragment_id: String
    premis_includes: object_file_arr_rel_insert_input
    premis_represents: object_ie_obj_rel_insert_input
    "label"
    schema_alternate_name: String
    "datum waarop de resource van de representation werd aangemaakt"
    schema_date_created: timestamp
    "de optionele beschrijving van de representatie zelf"
    schema_description: String
    "filename aka PathToVideo"
    schema_name: String
    "de geschreven neerslag van een IE zijn audio"
    schema_transcript: String
}

"order by max() on columns of table \"object.representation\""
input object_representation_max_order_by {
    "het bestandstype van de represenatatie, container"
    dcterms_format: order_by
    id: order_by
    "de FragmentId van de IE waarvan dit de representation is"
    ie_meemoo_fragment_id: order_by
    "label"
    schema_alternate_name: order_by
    "datum waarop de resource van de representation werd aangemaakt"
    schema_date_created: order_by
    "de optionele beschrijving van de representatie zelf"
    schema_description: order_by
    "filename aka PathToVideo"
    schema_name: order_by
    "de geschreven neerslag van een IE zijn audio"
    schema_transcript: order_by
}

"order by min() on columns of table \"object.representation\""
input object_representation_min_order_by {
    "het bestandstype van de represenatatie, container"
    dcterms_format: order_by
    id: order_by
    "de FragmentId van de IE waarvan dit de representation is"
    ie_meemoo_fragment_id: order_by
    "label"
    schema_alternate_name: order_by
    "datum waarop de resource van de representation werd aangemaakt"
    schema_date_created: order_by
    "de optionele beschrijving van de representatie zelf"
    schema_description: order_by
    "filename aka PathToVideo"
    schema_name: order_by
    "de geschreven neerslag van een IE zijn audio"
    schema_transcript: order_by
}

"input type for inserting object relation for remote table \"object.representation\""
input object_representation_obj_rel_insert_input {
    data: object_representation_insert_input!
    "on conflict condition"
    on_conflict: object_representation_on_conflict
}

"on conflict condition type for table \"object.representation\""
input object_representation_on_conflict {
    constraint: object_representation_constraint!
    update_columns: [object_representation_update_column!]! = []
    where: object_representation_bool_exp
}

"Ordering options when selecting data from \"object.representation\"."
input object_representation_order_by {
    dcterms_format: order_by
    id: order_by
    ie_meemoo_fragment_id: order_by
    premis_includes_aggregate: object_file_aggregate_order_by
    premis_represents: object_ie_order_by
    schema_alternate_name: order_by
    schema_date_created: order_by
    schema_description: order_by
    schema_name: order_by
    schema_transcript: order_by
}

"primary key columns input for table: object_representation"
input object_representation_pk_columns_input {
    id: String!
}

"input type for updating data in table \"object.representation\""
input object_representation_set_input {
    "het bestandstype van de represenatatie, container"
    dcterms_format: String
    id: String
    "de FragmentId van de IE waarvan dit de representation is"
    ie_meemoo_fragment_id: String
    "label"
    schema_alternate_name: String
    "datum waarop de resource van de representation werd aangemaakt"
    schema_date_created: timestamp
    "de optionele beschrijving van de representatie zelf"
    schema_description: String
    "filename aka PathToVideo"
    schema_name: String
    "de geschreven neerslag van een IE zijn audio"
    schema_transcript: String
}

"append existing jsonb value of filtered columns with new jsonb value"
input sync_audio_append_input {
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: jsonb
}

"Boolean expression to filter rows from the table \"sync.audio\". All fields are combined with a logical 'AND'."
input sync_audio_bool_exp {
    _and: [sync_audio_bool_exp!]
    _not: sync_audio_bool_exp
    _or: [sync_audio_bool_exp!]
    created_at: timestamptz_comparison_exp
    data: jsonb_comparison_exp
    meemoo_fragment_id: String_comparison_exp
    schema_identifier: String_comparison_exp
    schema_maintainer_id: String_comparison_exp
    schema_name: String_comparison_exp
    status: String_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input sync_audio_delete_at_path_input {
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input sync_audio_delete_elem_input {
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input sync_audio_delete_key_input {
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: String
}

"input type for inserting data into table \"sync.audio\""
input sync_audio_insert_input {
    created_at: timestamptz
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: jsonb
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String
    "De meemoo pid of external_id"
    schema_identifier: String
    "De OR-ID van de aanbiedende CP"
    schema_maintainer_id: String
    "De human readable titel van het object"
    schema_name: String
    status: String
    updated_at: timestamptz
}

"on conflict condition type for table \"sync.audio\""
input sync_audio_on_conflict {
    constraint: sync_audio_constraint!
    update_columns: [sync_audio_update_column!]! = []
    where: sync_audio_bool_exp
}

"Ordering options when selecting data from \"sync.audio\"."
input sync_audio_order_by {
    created_at: order_by
    data: order_by
    meemoo_fragment_id: order_by
    schema_identifier: order_by
    schema_maintainer_id: order_by
    schema_name: order_by
    status: order_by
    updated_at: order_by
}

"primary key columns input for table: sync_audio"
input sync_audio_pk_columns_input {
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input sync_audio_prepend_input {
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: jsonb
}

"input type for updating data in table \"sync.audio\""
input sync_audio_set_input {
    created_at: timestamptz
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: jsonb
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String
    "De meemoo pid of external_id"
    schema_identifier: String
    "De OR-ID van de aanbiedende CP"
    schema_maintainer_id: String
    "De human readable titel van het object"
    schema_name: String
    status: String
    updated_at: timestamptz
}

"append existing jsonb value of filtered columns with new jsonb value"
input sync_film_append_input {
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: jsonb
}

"Boolean expression to filter rows from the table \"sync.film\". All fields are combined with a logical 'AND'."
input sync_film_bool_exp {
    _and: [sync_film_bool_exp!]
    _not: sync_film_bool_exp
    _or: [sync_film_bool_exp!]
    created_at: timestamptz_comparison_exp
    data: jsonb_comparison_exp
    meemoo_fragment_id: String_comparison_exp
    schema_identifier: String_comparison_exp
    schema_maintainer_id: String_comparison_exp
    schema_name: String_comparison_exp
    status: String_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input sync_film_delete_at_path_input {
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input sync_film_delete_elem_input {
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input sync_film_delete_key_input {
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: String
}

"input type for inserting data into table \"sync.film\""
input sync_film_insert_input {
    created_at: timestamptz
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: jsonb
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String
    "De meemoo pid of external_id"
    schema_identifier: String
    "De OR-ID van de aanbiedende CP"
    schema_maintainer_id: String
    "De human readable titel van het object"
    schema_name: String
    status: String
    updated_at: timestamptz
}

"on conflict condition type for table \"sync.film\""
input sync_film_on_conflict {
    constraint: sync_film_constraint!
    update_columns: [sync_film_update_column!]! = []
    where: sync_film_bool_exp
}

"Ordering options when selecting data from \"sync.film\"."
input sync_film_order_by {
    created_at: order_by
    data: order_by
    meemoo_fragment_id: order_by
    schema_identifier: order_by
    schema_maintainer_id: order_by
    schema_name: order_by
    status: order_by
    updated_at: order_by
}

"primary key columns input for table: sync_film"
input sync_film_pk_columns_input {
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input sync_film_prepend_input {
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: jsonb
}

"input type for updating data in table \"sync.film\""
input sync_film_set_input {
    created_at: timestamptz
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: jsonb
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String
    "De meemoo pid of external_id"
    schema_identifier: String
    "De OR-ID van de aanbiedende CP"
    schema_maintainer_id: String
    "De human readable titel van het object"
    schema_name: String
    status: String
    updated_at: timestamptz
}

"append existing jsonb value of filtered columns with new jsonb value"
input sync_video_append_input {
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: jsonb
}

"Boolean expression to filter rows from the table \"sync.video\". All fields are combined with a logical 'AND'."
input sync_video_bool_exp {
    _and: [sync_video_bool_exp!]
    _not: sync_video_bool_exp
    _or: [sync_video_bool_exp!]
    created_at: timestamptz_comparison_exp
    data: jsonb_comparison_exp
    meemoo_fragment_id: String_comparison_exp
    schema_identifier: String_comparison_exp
    schema_maintainer_id: String_comparison_exp
    schema_name: String_comparison_exp
    status: String_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input sync_video_delete_at_path_input {
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input sync_video_delete_elem_input {
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input sync_video_delete_key_input {
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: String
}

"input type for inserting data into table \"sync.video\""
input sync_video_insert_input {
    created_at: timestamptz
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: jsonb
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String
    "De meemoo pid of external_id"
    schema_identifier: String
    "De OR-ID van de aanbiedende CP"
    schema_maintainer_id: String
    "De human readable titel van het object"
    schema_name: String
    status: String
    updated_at: timestamptz
}

"on conflict condition type for table \"sync.video\""
input sync_video_on_conflict {
    constraint: sync_video_constraint!
    update_columns: [sync_video_update_column!]! = []
    where: sync_video_bool_exp
}

"Ordering options when selecting data from \"sync.video\"."
input sync_video_order_by {
    created_at: order_by
    data: order_by
    meemoo_fragment_id: order_by
    schema_identifier: order_by
    schema_maintainer_id: order_by
    schema_name: order_by
    status: order_by
    updated_at: order_by
}

"primary key columns input for table: sync_video"
input sync_video_pk_columns_input {
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input sync_video_prepend_input {
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: jsonb
}

"input type for updating data in table \"sync.video\""
input sync_video_set_input {
    created_at: timestamptz
    "De ruwe data uit de json v2 response van de Mediahaven REST API"
    data: jsonb
    "De meest unieke key: de mediafragment ID uit Mediahaven"
    meemoo_fragment_id: String
    "De meemoo pid of external_id"
    schema_identifier: String
    "De OR-ID van de aanbiedende CP"
    schema_maintainer_id: String
    "De human readable titel van het object"
    schema_name: String
    status: String
    updated_at: timestamptz
}

"Boolean expression to compare columns of type \"time\". All fields are combined with logical 'AND'."
input time_comparison_exp {
    _eq: time
    _gt: time
    _gte: time
    _in: [time!]
    _is_null: Boolean
    _lt: time
    _lte: time
    _neq: time
    _nin: [time!]
}

"Boolean expression to compare columns of type \"timestamp\". All fields are combined with logical 'AND'."
input timestamp_comparison_exp {
    _eq: timestamp
    _gt: timestamp
    _gte: timestamp
    _in: [timestamp!]
    _is_null: Boolean
    _lt: timestamp
    _lte: timestamp
    _neq: timestamp
    _nin: [timestamp!]
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
    _eq: timestamptz
    _gt: timestamptz
    _gte: timestamptz
    _in: [timestamptz!]
    _is_null: Boolean
    _lt: timestamptz
    _lte: timestamptz
    _neq: timestamptz
    _nin: [timestamptz!]
}

"order by aggregate values of table \"users.collection\""
input users_collection_aggregate_order_by {
    count: order_by
    max: users_collection_max_order_by
    min: users_collection_min_order_by
}

"input type for inserting array relation for remote table \"users.collection\""
input users_collection_arr_rel_insert_input {
    data: [users_collection_insert_input!]!
    "on conflict condition"
    on_conflict: users_collection_on_conflict
}

"Boolean expression to filter rows from the table \"users.collection\". All fields are combined with a logical 'AND'."
input users_collection_bool_exp {
    _and: [users_collection_bool_exp!]
    _not: users_collection_bool_exp
    _or: [users_collection_bool_exp!]
    created_at: timestamp_comparison_exp
    id: uuid_comparison_exp
    ies: users_collection_ie_bool_exp
    is_default: Boolean_comparison_exp
    name: String_comparison_exp
    updated_at: timestamp_comparison_exp
    user_profile: users_profile_bool_exp
    user_profile_id: uuid_comparison_exp
}

"order by aggregate values of table \"users.collection_ie\""
input users_collection_ie_aggregate_order_by {
    count: order_by
    max: users_collection_ie_max_order_by
    min: users_collection_ie_min_order_by
}

"input type for inserting array relation for remote table \"users.collection_ie\""
input users_collection_ie_arr_rel_insert_input {
    data: [users_collection_ie_insert_input!]!
    "on conflict condition"
    on_conflict: users_collection_ie_on_conflict
}

"Boolean expression to filter rows from the table \"users.collection_ie\". All fields are combined with a logical 'AND'."
input users_collection_ie_bool_exp {
    _and: [users_collection_ie_bool_exp!]
    _not: users_collection_ie_bool_exp
    _or: [users_collection_ie_bool_exp!]
    collection: users_collection_bool_exp
    created_at: timestamp_comparison_exp
    ie: object_ie_bool_exp
    object_ie_meemoo_fragment_id: String_comparison_exp
    updated_at: timestamp_comparison_exp
    user_collection_id: uuid_comparison_exp
}

"input type for inserting data into table \"users.collection_ie\""
input users_collection_ie_insert_input {
    collection: users_collection_obj_rel_insert_input
    created_at: timestamp
    ie: object_ie_obj_rel_insert_input
    object_ie_meemoo_fragment_id: String
    updated_at: timestamp
    user_collection_id: uuid
}

"order by max() on columns of table \"users.collection_ie\""
input users_collection_ie_max_order_by {
    created_at: order_by
    object_ie_meemoo_fragment_id: order_by
    updated_at: order_by
    user_collection_id: order_by
}

"order by min() on columns of table \"users.collection_ie\""
input users_collection_ie_min_order_by {
    created_at: order_by
    object_ie_meemoo_fragment_id: order_by
    updated_at: order_by
    user_collection_id: order_by
}

"on conflict condition type for table \"users.collection_ie\""
input users_collection_ie_on_conflict {
    constraint: users_collection_ie_constraint!
    update_columns: [users_collection_ie_update_column!]! = []
    where: users_collection_ie_bool_exp
}

"Ordering options when selecting data from \"users.collection_ie\"."
input users_collection_ie_order_by {
    collection: users_collection_order_by
    created_at: order_by
    ie: object_ie_order_by
    object_ie_meemoo_fragment_id: order_by
    updated_at: order_by
    user_collection_id: order_by
}

"primary key columns input for table: users_collection_ie"
input users_collection_ie_pk_columns_input {
    object_ie_meemoo_fragment_id: String!
    user_collection_id: uuid!
}

"input type for updating data in table \"users.collection_ie\""
input users_collection_ie_set_input {
    created_at: timestamp
    object_ie_meemoo_fragment_id: String
    updated_at: timestamp
    user_collection_id: uuid
}

"input type for inserting data into table \"users.collection\""
input users_collection_insert_input {
    created_at: timestamp
    id: uuid
    ies: users_collection_ie_arr_rel_insert_input
    is_default: Boolean
    name: String
    updated_at: timestamp
    user_profile: users_profile_obj_rel_insert_input
    user_profile_id: uuid
}

"order by max() on columns of table \"users.collection\""
input users_collection_max_order_by {
    created_at: order_by
    id: order_by
    name: order_by
    updated_at: order_by
    user_profile_id: order_by
}

"order by min() on columns of table \"users.collection\""
input users_collection_min_order_by {
    created_at: order_by
    id: order_by
    name: order_by
    updated_at: order_by
    user_profile_id: order_by
}

"input type for inserting object relation for remote table \"users.collection\""
input users_collection_obj_rel_insert_input {
    data: users_collection_insert_input!
    "on conflict condition"
    on_conflict: users_collection_on_conflict
}

"on conflict condition type for table \"users.collection\""
input users_collection_on_conflict {
    constraint: users_collection_constraint!
    update_columns: [users_collection_update_column!]! = []
    where: users_collection_bool_exp
}

"Ordering options when selecting data from \"users.collection\"."
input users_collection_order_by {
    created_at: order_by
    id: order_by
    ies_aggregate: users_collection_ie_aggregate_order_by
    is_default: order_by
    name: order_by
    updated_at: order_by
    user_profile: users_profile_order_by
    user_profile_id: order_by
}

"primary key columns input for table: users_collection"
input users_collection_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"users.collection\""
input users_collection_set_input {
    created_at: timestamp
    id: uuid
    is_default: Boolean
    name: String
    updated_at: timestamp
    user_profile_id: uuid
}

"Boolean expression to filter rows from the table \"users.group\". All fields are combined with a logical 'AND'."
input users_group_bool_exp {
    _and: [users_group_bool_exp!]
    _not: users_group_bool_exp
    _or: [users_group_bool_exp!]
    created_at: timestamp_comparison_exp
    description: String_comparison_exp
    id: uuid_comparison_exp
    label: String_comparison_exp
    name: String_comparison_exp
    permissions: users_group_permission_bool_exp
    profiles: users_profile_bool_exp
    updated_at: timestamp_comparison_exp
}

"input type for inserting data into table \"users.group\""
input users_group_insert_input {
    created_at: timestamp
    description: String
    id: uuid
    label: String
    name: String
    permissions: users_group_permission_arr_rel_insert_input
    profiles: users_profile_arr_rel_insert_input
    updated_at: timestamp
}

"input type for inserting object relation for remote table \"users.group\""
input users_group_obj_rel_insert_input {
    data: users_group_insert_input!
    "on conflict condition"
    on_conflict: users_group_on_conflict
}

"on conflict condition type for table \"users.group\""
input users_group_on_conflict {
    constraint: users_group_constraint!
    update_columns: [users_group_update_column!]! = []
    where: users_group_bool_exp
}

"Ordering options when selecting data from \"users.group\"."
input users_group_order_by {
    created_at: order_by
    description: order_by
    id: order_by
    label: order_by
    name: order_by
    permissions_aggregate: users_group_permission_aggregate_order_by
    profiles_aggregate: users_profile_aggregate_order_by
    updated_at: order_by
}

"order by aggregate values of table \"users.group_permission\""
input users_group_permission_aggregate_order_by {
    count: order_by
    max: users_group_permission_max_order_by
    min: users_group_permission_min_order_by
}

"input type for inserting array relation for remote table \"users.group_permission\""
input users_group_permission_arr_rel_insert_input {
    data: [users_group_permission_insert_input!]!
    "on conflict condition"
    on_conflict: users_group_permission_on_conflict
}

"Boolean expression to filter rows from the table \"users.group_permission\". All fields are combined with a logical 'AND'."
input users_group_permission_bool_exp {
    _and: [users_group_permission_bool_exp!]
    _not: users_group_permission_bool_exp
    _or: [users_group_permission_bool_exp!]
    group: users_group_bool_exp
    group_id: uuid_comparison_exp
    id: uuid_comparison_exp
    permission: users_permission_bool_exp
    permission_id: uuid_comparison_exp
}

"input type for inserting data into table \"users.group_permission\""
input users_group_permission_insert_input {
    group: users_group_obj_rel_insert_input
    group_id: uuid
    id: uuid
    permission: users_permission_obj_rel_insert_input
    permission_id: uuid
}

"order by max() on columns of table \"users.group_permission\""
input users_group_permission_max_order_by {
    group_id: order_by
    id: order_by
    permission_id: order_by
}

"order by min() on columns of table \"users.group_permission\""
input users_group_permission_min_order_by {
    group_id: order_by
    id: order_by
    permission_id: order_by
}

"on conflict condition type for table \"users.group_permission\""
input users_group_permission_on_conflict {
    constraint: users_group_permission_constraint!
    update_columns: [users_group_permission_update_column!]! = []
    where: users_group_permission_bool_exp
}

"Ordering options when selecting data from \"users.group_permission\"."
input users_group_permission_order_by {
    group: users_group_order_by
    group_id: order_by
    id: order_by
    permission: users_permission_order_by
    permission_id: order_by
}

"primary key columns input for table: users_group_permission"
input users_group_permission_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"users.group_permission\""
input users_group_permission_set_input {
    group_id: uuid
    id: uuid
    permission_id: uuid
}

"primary key columns input for table: users_group"
input users_group_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"users.group\""
input users_group_set_input {
    created_at: timestamp
    description: String
    id: uuid
    label: String
    name: String
    updated_at: timestamp
}

"order by aggregate values of table \"users.identity\""
input users_identity_aggregate_order_by {
    count: order_by
    max: users_identity_max_order_by
    min: users_identity_min_order_by
}

"input type for inserting array relation for remote table \"users.identity\""
input users_identity_arr_rel_insert_input {
    data: [users_identity_insert_input!]!
    "on conflict condition"
    on_conflict: users_identity_on_conflict
}

"Boolean expression to filter rows from the table \"users.identity\". All fields are combined with a logical 'AND'."
input users_identity_bool_exp {
    _and: [users_identity_bool_exp!]
    _not: users_identity_bool_exp
    _or: [users_identity_bool_exp!]
    created_at: timestamptz_comparison_exp
    id: uuid_comparison_exp
    identity_id: String_comparison_exp
    identity_provider: users_identity_provider_bool_exp
    identity_provider_name: String_comparison_exp
    profile: users_profile_bool_exp
    profile_id: uuid_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"input type for inserting data into table \"users.identity\""
input users_identity_insert_input {
    created_at: timestamptz
    id: uuid
    identity_id: String
    identity_provider: users_identity_provider_obj_rel_insert_input
    identity_provider_name: String
    profile: users_profile_obj_rel_insert_input
    profile_id: uuid
    updated_at: timestamptz
}

"order by max() on columns of table \"users.identity\""
input users_identity_max_order_by {
    created_at: order_by
    id: order_by
    identity_id: order_by
    identity_provider_name: order_by
    profile_id: order_by
    updated_at: order_by
}

"order by min() on columns of table \"users.identity\""
input users_identity_min_order_by {
    created_at: order_by
    id: order_by
    identity_id: order_by
    identity_provider_name: order_by
    profile_id: order_by
    updated_at: order_by
}

"on conflict condition type for table \"users.identity\""
input users_identity_on_conflict {
    constraint: users_identity_constraint!
    update_columns: [users_identity_update_column!]! = []
    where: users_identity_bool_exp
}

"Ordering options when selecting data from \"users.identity\"."
input users_identity_order_by {
    created_at: order_by
    id: order_by
    identity_id: order_by
    identity_provider: users_identity_provider_order_by
    identity_provider_name: order_by
    profile: users_profile_order_by
    profile_id: order_by
    updated_at: order_by
}

"primary key columns input for table: users_identity"
input users_identity_pk_columns_input {
    id: uuid!
}

"Boolean expression to filter rows from the table \"users.identity_provider\". All fields are combined with a logical 'AND'."
input users_identity_provider_bool_exp {
    _and: [users_identity_provider_bool_exp!]
    _not: users_identity_provider_bool_exp
    _or: [users_identity_provider_bool_exp!]
    description: String_comparison_exp
    identities: users_identity_bool_exp
    name: String_comparison_exp
}

"input type for inserting data into table \"users.identity_provider\""
input users_identity_provider_insert_input {
    description: String
    identities: users_identity_arr_rel_insert_input
    name: String
}

"input type for inserting object relation for remote table \"users.identity_provider\""
input users_identity_provider_obj_rel_insert_input {
    data: users_identity_provider_insert_input!
    "on conflict condition"
    on_conflict: users_identity_provider_on_conflict
}

"on conflict condition type for table \"users.identity_provider\""
input users_identity_provider_on_conflict {
    constraint: users_identity_provider_constraint!
    update_columns: [users_identity_provider_update_column!]! = []
    where: users_identity_provider_bool_exp
}

"Ordering options when selecting data from \"users.identity_provider\"."
input users_identity_provider_order_by {
    description: order_by
    identities_aggregate: users_identity_aggregate_order_by
    name: order_by
}

"primary key columns input for table: users_identity_provider"
input users_identity_provider_pk_columns_input {
    name: String!
}

"input type for updating data in table \"users.identity_provider\""
input users_identity_provider_set_input {
    description: String
    name: String
}

"input type for updating data in table \"users.identity\""
input users_identity_set_input {
    created_at: timestamptz
    id: uuid
    identity_id: String
    identity_provider_name: String
    profile_id: uuid
    updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"users.permission\". All fields are combined with a logical 'AND'."
input users_permission_bool_exp {
    _and: [users_permission_bool_exp!]
    _not: users_permission_bool_exp
    _or: [users_permission_bool_exp!]
    created_at: timestamp_comparison_exp
    description: String_comparison_exp
    groups: users_group_permission_bool_exp
    id: uuid_comparison_exp
    label: String_comparison_exp
    name: String_comparison_exp
    updated_at: timestamp_comparison_exp
}

"input type for inserting data into table \"users.permission\""
input users_permission_insert_input {
    created_at: timestamp
    description: String
    groups: users_group_permission_arr_rel_insert_input
    id: uuid
    label: String
    name: String
    updated_at: timestamp
}

"input type for inserting object relation for remote table \"users.permission\""
input users_permission_obj_rel_insert_input {
    data: users_permission_insert_input!
    "on conflict condition"
    on_conflict: users_permission_on_conflict
}

"on conflict condition type for table \"users.permission\""
input users_permission_on_conflict {
    constraint: users_permission_constraint!
    update_columns: [users_permission_update_column!]! = []
    where: users_permission_bool_exp
}

"Ordering options when selecting data from \"users.permission\"."
input users_permission_order_by {
    created_at: order_by
    description: order_by
    groups_aggregate: users_group_permission_aggregate_order_by
    id: order_by
    label: order_by
    name: order_by
    updated_at: order_by
}

"primary key columns input for table: users_permission"
input users_permission_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"users.permission\""
input users_permission_set_input {
    created_at: timestamp
    description: String
    id: uuid
    label: String
    name: String
    updated_at: timestamp
}

"order by aggregate values of table \"users.profile\""
input users_profile_aggregate_order_by {
    count: order_by
    max: users_profile_max_order_by
    min: users_profile_min_order_by
}

"input type for inserting array relation for remote table \"users.profile\""
input users_profile_arr_rel_insert_input {
    data: [users_profile_insert_input!]!
    "on conflict condition"
    on_conflict: users_profile_on_conflict
}

"Boolean expression to filter rows from the table \"users.profile\". All fields are combined with a logical 'AND'."
input users_profile_bool_exp {
    _and: [users_profile_bool_exp!]
    _not: users_profile_bool_exp
    _or: [users_profile_bool_exp!]
    accepted_tos_at: timestamptz_comparison_exp
    collections: users_collection_bool_exp
    contents: cms_content_bool_exp
    contentsByUserProfileId: cms_content_bool_exp
    created_at: timestamp_comparison_exp
    first_name: String_comparison_exp
    full_name: String_comparison_exp
    group: users_group_bool_exp
    group_id: uuid_comparison_exp
    id: uuid_comparison_exp
    identities: users_identity_bool_exp
    last_name: String_comparison_exp
    mail: String_comparison_exp
    maintainer_users_profiles: cp_maintainer_users_profile_bool_exp
    notes: cp_visit_note_bool_exp
    notifications: app_notification_bool_exp
    updated_at: timestamp_comparison_exp
    visits: cp_visit_bool_exp
    visitsByUpdatedBy: cp_visit_bool_exp
}

"input type for inserting data into table \"users.profile\""
input users_profile_insert_input {
    accepted_tos_at: timestamptz
    collections: users_collection_arr_rel_insert_input
    contents: cms_content_arr_rel_insert_input
    contentsByUserProfileId: cms_content_arr_rel_insert_input
    created_at: timestamp
    first_name: String
    group: users_group_obj_rel_insert_input
    group_id: uuid
    id: uuid
    identities: users_identity_arr_rel_insert_input
    last_name: String
    mail: String
    maintainer_users_profiles: cp_maintainer_users_profile_arr_rel_insert_input
    notes: cp_visit_note_arr_rel_insert_input
    notifications: app_notification_arr_rel_insert_input
    updated_at: timestamp
    visits: cp_visit_arr_rel_insert_input
    visitsByUpdatedBy: cp_visit_arr_rel_insert_input
}

"order by max() on columns of table \"users.profile\""
input users_profile_max_order_by {
    accepted_tos_at: order_by
    created_at: order_by
    first_name: order_by
    group_id: order_by
    id: order_by
    last_name: order_by
    mail: order_by
    updated_at: order_by
}

"order by min() on columns of table \"users.profile\""
input users_profile_min_order_by {
    accepted_tos_at: order_by
    created_at: order_by
    first_name: order_by
    group_id: order_by
    id: order_by
    last_name: order_by
    mail: order_by
    updated_at: order_by
}

"input type for inserting object relation for remote table \"users.profile\""
input users_profile_obj_rel_insert_input {
    data: users_profile_insert_input!
    "on conflict condition"
    on_conflict: users_profile_on_conflict
}

"on conflict condition type for table \"users.profile\""
input users_profile_on_conflict {
    constraint: users_profile_constraint!
    update_columns: [users_profile_update_column!]! = []
    where: users_profile_bool_exp
}

"Ordering options when selecting data from \"users.profile\"."
input users_profile_order_by {
    accepted_tos_at: order_by
    collections_aggregate: users_collection_aggregate_order_by
    contentsByUserProfileId_aggregate: cms_content_aggregate_order_by
    contents_aggregate: cms_content_aggregate_order_by
    created_at: order_by
    first_name: order_by
    full_name: order_by
    group: users_group_order_by
    group_id: order_by
    id: order_by
    identities_aggregate: users_identity_aggregate_order_by
    last_name: order_by
    mail: order_by
    maintainer_users_profiles_aggregate: cp_maintainer_users_profile_aggregate_order_by
    notes_aggregate: cp_visit_note_aggregate_order_by
    notifications_aggregate: app_notification_aggregate_order_by
    updated_at: order_by
    visitsByUpdatedBy_aggregate: cp_visit_aggregate_order_by
    visits_aggregate: cp_visit_aggregate_order_by
}

"primary key columns input for table: users_profile"
input users_profile_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"users.profile\""
input users_profile_set_input {
    accepted_tos_at: timestamptz
    created_at: timestamp
    first_name: String
    group_id: uuid
    id: uuid
    last_name: String
    mail: String
    updated_at: timestamp
}

"Boolean expression to compare columns of type \"uuid\". All fields are combined with logical 'AND'."
input uuid_comparison_exp {
    _eq: uuid
    _gt: uuid
    _gte: uuid
    _in: [uuid!]
    _is_null: Boolean
    _lt: uuid
    _lte: uuid
    _neq: uuid
    _nin: [uuid!]
}
